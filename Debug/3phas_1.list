
C:\Users\erikv\Documents\3phas\3phas_1\Debug\3phas_1.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000018c  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00001754  0800018c  0800018c  0001018c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000240  080018e0  080018e0  000118e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  08001b20  08001b20  00011b20  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  08001b24  08001b24  00011b24  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         00000004  20000000  08001b28  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00000060  20000004  08001b2c  00020004  2**2
                  ALLOC
  7 ._user_heap_stack 00000600  20000064  08001b2c  00020064  2**0
                  ALLOC
  8 .ARM.attributes 00000030  00000000  00000000  00020004  2**0
                  CONTENTS, READONLY
  9 .debug_info   0000a224  00000000  00000000  00020034  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00001749  00000000  00000000  0002a258  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000071ca  00000000  00000000  0002b9a1  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_aranges 000007d0  00000000  00000000  00032b70  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000b48  00000000  00000000  00033340  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   00003fb9  00000000  00000000  00033e88  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00002d82  00000000  00000000  00037e41  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .comment      0000007e  00000000  00000000  0003abc3  2**0
                  CONTENTS, READONLY
 17 .debug_frame  00001720  00000000  00000000  0003ac44  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0800018c <__do_global_dtors_aux>:
 800018c:	b510      	push	{r4, lr}
 800018e:	4c05      	ldr	r4, [pc, #20]	; (80001a4 <__do_global_dtors_aux+0x18>)
 8000190:	7823      	ldrb	r3, [r4, #0]
 8000192:	b933      	cbnz	r3, 80001a2 <__do_global_dtors_aux+0x16>
 8000194:	4b04      	ldr	r3, [pc, #16]	; (80001a8 <__do_global_dtors_aux+0x1c>)
 8000196:	b113      	cbz	r3, 800019e <__do_global_dtors_aux+0x12>
 8000198:	4804      	ldr	r0, [pc, #16]	; (80001ac <__do_global_dtors_aux+0x20>)
 800019a:	f3af 8000 	nop.w
 800019e:	2301      	movs	r3, #1
 80001a0:	7023      	strb	r3, [r4, #0]
 80001a2:	bd10      	pop	{r4, pc}
 80001a4:	20000004 	.word	0x20000004
 80001a8:	00000000 	.word	0x00000000
 80001ac:	080018c8 	.word	0x080018c8

080001b0 <frame_dummy>:
 80001b0:	b508      	push	{r3, lr}
 80001b2:	4b03      	ldr	r3, [pc, #12]	; (80001c0 <frame_dummy+0x10>)
 80001b4:	b11b      	cbz	r3, 80001be <frame_dummy+0xe>
 80001b6:	4903      	ldr	r1, [pc, #12]	; (80001c4 <frame_dummy+0x14>)
 80001b8:	4803      	ldr	r0, [pc, #12]	; (80001c8 <frame_dummy+0x18>)
 80001ba:	f3af 8000 	nop.w
 80001be:	bd08      	pop	{r3, pc}
 80001c0:	00000000 	.word	0x00000000
 80001c4:	20000008 	.word	0x20000008
 80001c8:	080018c8 	.word	0x080018c8

080001cc <HAL_InitTick>:
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(SystemCoreClock/1000);
 80001cc:	4b08      	ldr	r3, [pc, #32]	; (80001f0 <HAL_InitTick+0x24>)
 80001ce:	4a09      	ldr	r2, [pc, #36]	; (80001f4 <HAL_InitTick+0x28>)
 80001d0:	681b      	ldr	r3, [r3, #0]
  *       implementation  in user file.
  * @param TickPriority  Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 80001d2:	b510      	push	{r4, lr}
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(SystemCoreClock/1000);
 80001d4:	fba2 2303 	umull	r2, r3, r2, r3
  *       implementation  in user file.
  * @param TickPriority  Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 80001d8:	4604      	mov	r4, r0
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(SystemCoreClock/1000);
 80001da:	0998      	lsrs	r0, r3, #6
 80001dc:	f000 f870 	bl	80002c0 <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0);
 80001e0:	4621      	mov	r1, r4
 80001e2:	2200      	movs	r2, #0
 80001e4:	f04f 30ff 	mov.w	r0, #4294967295
 80001e8:	f000 f832 	bl	8000250 <HAL_NVIC_SetPriority>

  /* Return function status */
  return HAL_OK;
}
 80001ec:	2000      	movs	r0, #0
 80001ee:	bd10      	pop	{r4, pc}
 80001f0:	20000000 	.word	0x20000000
 80001f4:	10624dd3 	.word	0x10624dd3

080001f8 <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 80001f8:	b508      	push	{r3, lr}
#if (PREFETCH_ENABLE != 0)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80001fa:	2003      	movs	r0, #3
 80001fc:	f000 f816 	bl	800022c <HAL_NVIC_SetPriorityGrouping>

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 8000200:	2000      	movs	r0, #0
 8000202:	f7ff ffe3 	bl	80001cc <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 8000206:	f001 fa61 	bl	80016cc <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
}
 800020a:	2000      	movs	r0, #0
 800020c:	bd08      	pop	{r3, pc}
 800020e:	bf00      	nop

08000210 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 8000210:	4a02      	ldr	r2, [pc, #8]	; (800021c <HAL_IncTick+0xc>)
 8000212:	6813      	ldr	r3, [r2, #0]
 8000214:	3301      	adds	r3, #1
 8000216:	6013      	str	r3, [r2, #0]
 8000218:	4770      	bx	lr
 800021a:	bf00      	nop
 800021c:	20000020 	.word	0x20000020

08000220 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000220:	4b01      	ldr	r3, [pc, #4]	; (8000228 <HAL_GetTick+0x8>)
 8000222:	6818      	ldr	r0, [r3, #0]
}
 8000224:	4770      	bx	lr
 8000226:	bf00      	nop
 8000228:	20000020 	.word	0x20000020

0800022c <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800022c:	4a07      	ldr	r2, [pc, #28]	; (800024c <HAL_NVIC_SetPriorityGrouping+0x20>)
 800022e:	68d1      	ldr	r1, [r2, #12]
 8000230:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 8000234:	400b      	ands	r3, r1
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8000236:	0200      	lsls	r0, r0, #8
 8000238:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 800023c:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
 8000240:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8000244:	4303      	orrs	r3, r0
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8000246:	60d3      	str	r3, [r2, #12]
 8000248:	4770      	bx	lr
 800024a:	bf00      	nop
 800024c:	e000ed00 	.word	0xe000ed00

08000250 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8000250:	4b19      	ldr	r3, [pc, #100]	; (80002b8 <HAL_NVIC_SetPriority+0x68>)
 8000252:	68db      	ldr	r3, [r3, #12]
 8000254:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8000258:	b430      	push	{r4, r5}
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800025a:	f1c3 0507 	rsb	r5, r3, #7
 800025e:	2d04      	cmp	r5, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000260:	f103 0404 	add.w	r4, r3, #4
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000264:	bf28      	it	cs
 8000266:	2504      	movcs	r5, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000268:	2c06      	cmp	r4, #6
 800026a:	d918      	bls.n	800029e <HAL_NVIC_SetPriority+0x4e>
 800026c:	3b03      	subs	r3, #3
 800026e:	2401      	movs	r4, #1
 8000270:	409c      	lsls	r4, r3
 8000272:	3c01      	subs	r4, #1
 8000274:	4022      	ands	r2, r4

  return (
 8000276:	2401      	movs	r4, #1
 8000278:	40ac      	lsls	r4, r5
 800027a:	3c01      	subs	r4, #1
 800027c:	4021      	ands	r1, r4
 800027e:	fa01 f303 	lsl.w	r3, r1, r3
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
 8000282:	2800      	cmp	r0, #0
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 8000284:	ea42 0203 	orr.w	r2, r2, r3
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
 8000288:	db0c      	blt.n	80002a4 <HAL_NVIC_SetPriority+0x54>
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800028a:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 800028e:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 8000292:	0112      	lsls	r2, r2, #4
 8000294:	b2d2      	uxtb	r2, r2
 8000296:	f880 2300 	strb.w	r2, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 800029a:	bc30      	pop	{r4, r5}
 800029c:	4770      	bx	lr
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800029e:	2200      	movs	r2, #0
 80002a0:	4613      	mov	r3, r2
 80002a2:	e7e8      	b.n	8000276 <HAL_NVIC_SetPriority+0x26>
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80002a4:	4b05      	ldr	r3, [pc, #20]	; (80002bc <HAL_NVIC_SetPriority+0x6c>)
 80002a6:	f000 000f 	and.w	r0, r0, #15
 80002aa:	0112      	lsls	r2, r2, #4
 80002ac:	4403      	add	r3, r0
 80002ae:	b2d2      	uxtb	r2, r2
 80002b0:	761a      	strb	r2, [r3, #24]
 80002b2:	bc30      	pop	{r4, r5}
 80002b4:	4770      	bx	lr
 80002b6:	bf00      	nop
 80002b8:	e000ed00 	.word	0xe000ed00
 80002bc:	e000ecfc 	.word	0xe000ecfc

080002c0 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 80002c0:	3801      	subs	r0, #1
 80002c2:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 80002c6:	d20e      	bcs.n	80002e6 <HAL_SYSTICK_Config+0x26>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80002c8:	4b08      	ldr	r3, [pc, #32]	; (80002ec <HAL_SYSTICK_Config+0x2c>)
  * @param  TicksNumb: Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 80002ca:	b410      	push	{r4}
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80002cc:	4c08      	ldr	r4, [pc, #32]	; (80002f0 <HAL_SYSTICK_Config+0x30>)
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80002ce:	6058      	str	r0, [r3, #4]
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80002d0:	20f0      	movs	r0, #240	; 0xf0
 80002d2:	f884 0023 	strb.w	r0, [r4, #35]	; 0x23
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80002d6:	2200      	movs	r2, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80002d8:	2107      	movs	r1, #7
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 80002da:	4610      	mov	r0, r2
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80002dc:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80002de:	6019      	str	r1, [r3, #0]
   return SysTick_Config(TicksNumb);
}
 80002e0:	f85d 4b04 	ldr.w	r4, [sp], #4
 80002e4:	4770      	bx	lr
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
 80002e6:	2001      	movs	r0, #1
 80002e8:	4770      	bx	lr
 80002ea:	bf00      	nop
 80002ec:	e000e010 	.word	0xe000e010
 80002f0:	e000ed00 	.word	0xe000ed00

080002f4 <HAL_SYSTICK_CLKSourceConfig>:
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 80002f4:	4a04      	ldr	r2, [pc, #16]	; (8000308 <HAL_SYSTICK_CLKSourceConfig+0x14>)
 80002f6:	6813      	ldr	r3, [r2, #0]
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
 80002f8:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 80002fa:	bf0c      	ite	eq
 80002fc:	f043 0304 	orreq.w	r3, r3, #4
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
 8000300:	f023 0304 	bicne.w	r3, r3, #4
 8000304:	6013      	str	r3, [r2, #0]
 8000306:	4770      	bx	lr
 8000308:	e000e010 	.word	0xe000e010

0800030c <HAL_SYSTICK_Callback>:
/**
  * @brief  SYSTICK callback.
  * @retval None
  */
__weak void HAL_SYSTICK_Callback(void)
{
 800030c:	4770      	bx	lr
 800030e:	bf00      	nop

08000310 <HAL_SYSTICK_IRQHandler>:
/**
  * @brief  Handle SYSTICK interrupt request.
  * @retval None
  */
void HAL_SYSTICK_IRQHandler(void)
{
 8000310:	b508      	push	{r3, lr}
  HAL_SYSTICK_Callback();
 8000312:	f7ff fffb 	bl	800030c <HAL_SYSTICK_Callback>
 8000316:	bd08      	pop	{r3, pc}

08000318 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000318:	468c      	mov	ip, r1
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
 800031a:	6809      	ldr	r1, [r1, #0]
 800031c:	2900      	cmp	r1, #0
 800031e:	f000 80c6 	beq.w	80004ae <HAL_GPIO_Init+0x196>
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000322:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 8000326:	f8df e194 	ldr.w	lr, [pc, #404]	; 80004bc <HAL_GPIO_Init+0x1a4>
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 800032a:	b083      	sub	sp, #12
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
 800032c:	2500      	movs	r5, #0
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1U << position);
 800032e:	f04f 0801 	mov.w	r8, #1
 8000332:	e070      	b.n	8000416 <HAL_GPIO_Init+0xfe>
 8000334:	ea4f 0945 	mov.w	r9, r5, lsl #1
        GPIOx->AFR[position >> 3] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
 8000338:	2303      	movs	r3, #3
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
        GPIOx->AFR[position >> 3] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 800033a:	f8d0 a000 	ldr.w	sl, [r0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
 800033e:	fa03 f309 	lsl.w	r3, r3, r9
 8000342:	43db      	mvns	r3, r3
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8000344:	f004 0b03 	and.w	fp, r4, #3
        GPIOx->AFR[position >> 3] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
 8000348:	ea0a 0a03 	and.w	sl, sl, r3
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 800034c:	fa0b fb09 	lsl.w	fp, fp, r9
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000350:	3f01      	subs	r7, #1
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8000352:	ea4b 0a0a 	orr.w	sl, fp, sl
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000356:	2f01      	cmp	r7, #1

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
      GPIOx->MODER = temp;
 8000358:	f8c0 a000 	str.w	sl, [r0]

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800035c:	f240 808b 	bls.w	8000476 <HAL_GPIO_Init+0x15e>
      }

#endif /* STM32L471xx || STM32L475xx || STM32L476xx || STM32L485xx || STM32L486xx */

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 8000360:	68c7      	ldr	r7, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2));
      temp |= ((GPIO_Init->Pull) << (position * 2));
 8000362:	f8dc 2008 	ldr.w	r2, [ip, #8]

#endif /* STM32L471xx || STM32L475xx || STM32L476xx || STM32L485xx || STM32L486xx */

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2));
 8000366:	403b      	ands	r3, r7
      temp |= ((GPIO_Init->Pull) << (position * 2));
 8000368:	fa02 f209 	lsl.w	r2, r2, r9
 800036c:	4313      	orrs	r3, r2
      GPIOx->PUPDR = temp;
 800036e:	60c3      	str	r3, [r0, #12]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8000370:	00e3      	lsls	r3, r4, #3
 8000372:	d54c      	bpl.n	800040e <HAL_GPIO_Init+0xf6>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000374:	4b4e      	ldr	r3, [pc, #312]	; (80004b0 <HAL_GPIO_Init+0x198>)
 8000376:	4a4e      	ldr	r2, [pc, #312]	; (80004b0 <HAL_GPIO_Init+0x198>)
 8000378:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800037a:	f043 0301 	orr.w	r3, r3, #1
 800037e:	6613      	str	r3, [r2, #96]	; 0x60
 8000380:	6e13      	ldr	r3, [r2, #96]	; 0x60
 8000382:	f025 0203 	bic.w	r2, r5, #3
 8000386:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 800038a:	f003 0301 	and.w	r3, r3, #1
 800038e:	f502 3280 	add.w	r2, r2, #65536	; 0x10000
 8000392:	9301      	str	r3, [sp, #4]

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8000394:	f005 0303 	and.w	r3, r5, #3
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000398:	9f01      	ldr	r7, [sp, #4]

        temp = SYSCFG->EXTICR[position >> 2];
 800039a:	6897      	ldr	r7, [r2, #8]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 800039c:	009b      	lsls	r3, r3, #2
 800039e:	f04f 090f 	mov.w	r9, #15
 80003a2:	fa09 f903 	lsl.w	r9, r9, r3
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
 80003a6:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 80003aa:	ea27 0909 	bic.w	r9, r7, r9
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
 80003ae:	d079      	beq.n	80004a4 <HAL_GPIO_Init+0x18c>
 80003b0:	4f40      	ldr	r7, [pc, #256]	; (80004b4 <HAL_GPIO_Init+0x19c>)
 80003b2:	42b8      	cmp	r0, r7
 80003b4:	d078      	beq.n	80004a8 <HAL_GPIO_Init+0x190>
 80003b6:	4f40      	ldr	r7, [pc, #256]	; (80004b8 <HAL_GPIO_Init+0x1a0>)
 80003b8:	42b8      	cmp	r0, r7
 80003ba:	bf0c      	ite	eq
 80003bc:	2702      	moveq	r7, #2
 80003be:	2707      	movne	r7, #7
 80003c0:	fa07 f303 	lsl.w	r3, r7, r3
 80003c4:	ea43 0309 	orr.w	r3, r3, r9
        SYSCFG->EXTICR[position >> 2] = temp;
 80003c8:	6093      	str	r3, [r2, #8]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 80003ca:	f8de 3000 	ldr.w	r3, [lr]
        temp &= ~((uint32_t)iocurrent);
 80003ce:	43f2      	mvns	r2, r6
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 80003d0:	03e7      	lsls	r7, r4, #15
        {
          temp |= iocurrent;
 80003d2:	bf4c      	ite	mi
 80003d4:	4333      	orrmi	r3, r6
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
        temp &= ~((uint32_t)iocurrent);
 80003d6:	4013      	andpl	r3, r2
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
        {
          temp |= iocurrent;
        }
        EXTI->IMR1 = temp;
 80003d8:	f8ce 3000 	str.w	r3, [lr]

        temp = EXTI->EMR1;
 80003dc:	f8de 3004 	ldr.w	r3, [lr, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 80003e0:	03a7      	lsls	r7, r4, #14
        {
          temp |= iocurrent;
 80003e2:	bf4c      	ite	mi
 80003e4:	4333      	orrmi	r3, r6
          temp |= iocurrent;
        }
        EXTI->IMR1 = temp;

        temp = EXTI->EMR1;
        temp &= ~((uint32_t)iocurrent);
 80003e6:	4013      	andpl	r3, r2
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
        {
          temp |= iocurrent;
        }
        EXTI->EMR1 = temp;
 80003e8:	f8ce 3004 	str.w	r3, [lr, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 80003ec:	f8de 3008 	ldr.w	r3, [lr, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 80003f0:	02e7      	lsls	r7, r4, #11
        {
          temp |= iocurrent;
 80003f2:	bf4c      	ite	mi
 80003f4:	4333      	orrmi	r3, r6
        }
        EXTI->EMR1 = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
        temp &= ~((uint32_t)iocurrent);
 80003f6:	4013      	andpl	r3, r2
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
        {
          temp |= iocurrent;
        }
        EXTI->RTSR1 = temp;
 80003f8:	f8ce 3008 	str.w	r3, [lr, #8]

        temp = EXTI->FTSR1;
 80003fc:	f8de 300c 	ldr.w	r3, [lr, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8000400:	02a4      	lsls	r4, r4, #10
          temp |= iocurrent;
        }
        EXTI->RTSR1 = temp;

        temp = EXTI->FTSR1;
        temp &= ~((uint32_t)iocurrent);
 8000402:	bf54      	ite	pl
 8000404:	ea02 0603 	andpl.w	r6, r2, r3
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
        {
          temp |= iocurrent;
 8000408:	431e      	orrmi	r6, r3
        }
        EXTI->FTSR1 = temp;
 800040a:	f8ce 600c 	str.w	r6, [lr, #12]
      }
    }
    
    position++;
 800040e:	3501      	adds	r5, #1
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
 8000410:	fa31 f305 	lsrs.w	r3, r1, r5
 8000414:	d043      	beq.n	800049e <HAL_GPIO_Init+0x186>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1U << position);
 8000416:	fa08 f205 	lsl.w	r2, r8, r5

    if(iocurrent)
 800041a:	ea12 0601 	ands.w	r6, r2, r1
 800041e:	d0f6      	beq.n	800040e <HAL_GPIO_Init+0xf6>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8000420:	f8dc 4004 	ldr.w	r4, [ip, #4]
 8000424:	f024 0710 	bic.w	r7, r4, #16
 8000428:	2f02      	cmp	r7, #2
 800042a:	d183      	bne.n	8000334 <HAL_GPIO_Init+0x1c>
 800042c:	ea4f 0ad5 	mov.w	sl, r5, lsr #3
 8000430:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3];
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8000434:	f005 0707 	and.w	r7, r5, #7
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3];
 8000438:	f8da 3020 	ldr.w	r3, [sl, #32]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 800043c:	00bf      	lsls	r7, r7, #2
 800043e:	f04f 090f 	mov.w	r9, #15
 8000442:	fa09 fb07 	lsl.w	fp, r9, r7
 8000446:	ea23 090b 	bic.w	r9, r3, fp
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 800044a:	f8dc 3010 	ldr.w	r3, [ip, #16]
 800044e:	40bb      	lsls	r3, r7
 8000450:	ea43 0309 	orr.w	r3, r3, r9
        GPIOx->AFR[position >> 3] = temp;
 8000454:	f8ca 3020 	str.w	r3, [sl, #32]
 8000458:	ea4f 0945 	mov.w	r9, r5, lsl #1
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
 800045c:	2303      	movs	r3, #3
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
        GPIOx->AFR[position >> 3] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 800045e:	6807      	ldr	r7, [r0, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
 8000460:	fa03 f309 	lsl.w	r3, r3, r9
 8000464:	43db      	mvns	r3, r3
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8000466:	f004 0a03 	and.w	sl, r4, #3
        GPIOx->AFR[position >> 3] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
 800046a:	401f      	ands	r7, r3
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 800046c:	fa0a fa09 	lsl.w	sl, sl, r9
 8000470:	ea4a 0707 	orr.w	r7, sl, r7
      GPIOx->MODER = temp;
 8000474:	6007      	str	r7, [r0, #0]
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 8000476:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2));
 8000478:	ea07 0a03 	and.w	sl, r7, r3
        temp |= (GPIO_Init->Speed << (position * 2));
 800047c:	f8dc 700c 	ldr.w	r7, [ip, #12]
 8000480:	fa07 f709 	lsl.w	r7, r7, r9
 8000484:	ea47 070a 	orr.w	r7, r7, sl
        GPIOx->OSPEEDR = temp;
 8000488:	6087      	str	r7, [r0, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 800048a:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 800048c:	f3c4 1a00 	ubfx	sl, r4, #4, #1
        temp |= (GPIO_Init->Speed << (position * 2));
        GPIOx->OSPEEDR = temp;

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8000490:	ea27 0702 	bic.w	r7, r7, r2
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 8000494:	4652      	mov	r2, sl
 8000496:	40aa      	lsls	r2, r5
 8000498:	433a      	orrs	r2, r7
        GPIOx->OTYPER = temp;
 800049a:	6042      	str	r2, [r0, #4]
 800049c:	e760      	b.n	8000360 <HAL_GPIO_Init+0x48>
      }
    }
    
    position++;
  }
}
 800049e:	b003      	add	sp, #12
 80004a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80004a4:	2300      	movs	r3, #0
 80004a6:	e78d      	b.n	80003c4 <HAL_GPIO_Init+0xac>
 80004a8:	fa08 f303 	lsl.w	r3, r8, r3
 80004ac:	e78a      	b.n	80003c4 <HAL_GPIO_Init+0xac>
 80004ae:	4770      	bx	lr
 80004b0:	40021000 	.word	0x40021000
 80004b4:	48000400 	.word	0x48000400
 80004b8:	48000800 	.word	0x48000800
 80004bc:	40010400 	.word	0x40010400

080004c0 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 80004c0:	b90a      	cbnz	r2, 80004c6 <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 80004c2:	6281      	str	r1, [r0, #40]	; 0x28
 80004c4:	4770      	bx	lr
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 80004c6:	6181      	str	r1, [r0, #24]
 80004c8:	4770      	bx	lr
 80004ca:	bf00      	nop

080004cc <HAL_PWREx_GetVoltageRange>:
    else
    {
      return PWR_REGULATOR_VOLTAGE_SCALE1_BOOST;
    }
#else
  return  (PWR->CR1 & PWR_CR1_VOS);
 80004cc:	4b02      	ldr	r3, [pc, #8]	; (80004d8 <HAL_PWREx_GetVoltageRange+0xc>)
 80004ce:	6818      	ldr	r0, [r3, #0]
#endif  
}
 80004d0:	f400 60c0 	and.w	r0, r0, #1536	; 0x600
 80004d4:	4770      	bx	lr
 80004d6:	bf00      	nop
 80004d8:	40007000 	.word	0x40007000

080004dc <HAL_PWREx_ControlVoltageScaling>:
  }
  
#else

  /* If Set Range 1 */
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
 80004dc:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 80004e0:	d00e      	beq.n	8000500 <HAL_PWREx_ControlVoltageScaling+0x24>
      }
    }
  }
  else
  {
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE2)
 80004e2:	4a19      	ldr	r2, [pc, #100]	; (8000548 <HAL_PWREx_ControlVoltageScaling+0x6c>)
 80004e4:	6813      	ldr	r3, [r2, #0]
 80004e6:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 80004ea:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80004ee:	d005      	beq.n	80004fc <HAL_PWREx_ControlVoltageScaling+0x20>
    {
      /* Set Range 2 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE2);
 80004f0:	6813      	ldr	r3, [r2, #0]
 80004f2:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 80004f6:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 80004fa:	6013      	str	r3, [r2, #0]
      /* No need to wait for VOSF to be cleared for this transition */
    }
  }
#endif  
  
  return HAL_OK;
 80004fc:	2000      	movs	r0, #0
 80004fe:	4770      	bx	lr
#else

  /* If Set Range 1 */
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
  {
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE1)
 8000500:	4911      	ldr	r1, [pc, #68]	; (8000548 <HAL_PWREx_ControlVoltageScaling+0x6c>)
 8000502:	680b      	ldr	r3, [r1, #0]
 8000504:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 8000508:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800050c:	d0f6      	beq.n	80004fc <HAL_PWREx_ControlVoltageScaling+0x20>
    {
      /* Set Range 1 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 800050e:	6808      	ldr	r0, [r1, #0]
      
      /* Wait until VOSF is cleared */      
      wait_loop_index = (PWR_FLAG_SETTING_DELAY_US * (SystemCoreClock / 1000000));
 8000510:	4b0e      	ldr	r3, [pc, #56]	; (800054c <HAL_PWREx_ControlVoltageScaling+0x70>)
 8000512:	4a0f      	ldr	r2, [pc, #60]	; (8000550 <HAL_PWREx_ControlVoltageScaling+0x74>)
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
  {
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE1)
    {
      /* Set Range 1 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 8000514:	f420 60c0 	bic.w	r0, r0, #1536	; 0x600
 8000518:	f440 7000 	orr.w	r0, r0, #512	; 0x200
 800051c:	6008      	str	r0, [r1, #0]
      
      /* Wait until VOSF is cleared */      
      wait_loop_index = (PWR_FLAG_SETTING_DELAY_US * (SystemCoreClock / 1000000));
 800051e:	681b      	ldr	r3, [r3, #0]
 8000520:	fba2 2303 	umull	r2, r3, r2, r3
 8000524:	0c9a      	lsrs	r2, r3, #18
 8000526:	2332      	movs	r3, #50	; 0x32
 8000528:	fb03 f302 	mul.w	r3, r3, r2
      while ((wait_loop_index != 0) && (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)))
 800052c:	b913      	cbnz	r3, 8000534 <HAL_PWREx_ControlVoltageScaling+0x58>
 800052e:	e004      	b.n	800053a <HAL_PWREx_ControlVoltageScaling+0x5e>
 8000530:	3b01      	subs	r3, #1
 8000532:	d002      	beq.n	800053a <HAL_PWREx_ControlVoltageScaling+0x5e>
 8000534:	694a      	ldr	r2, [r1, #20]
 8000536:	0552      	lsls	r2, r2, #21
 8000538:	d4fa      	bmi.n	8000530 <HAL_PWREx_ControlVoltageScaling+0x54>
      {
        wait_loop_index--;
      }
      if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
 800053a:	4b03      	ldr	r3, [pc, #12]	; (8000548 <HAL_PWREx_ControlVoltageScaling+0x6c>)
 800053c:	695b      	ldr	r3, [r3, #20]
 800053e:	055b      	lsls	r3, r3, #21
 8000540:	d5dc      	bpl.n	80004fc <HAL_PWREx_ControlVoltageScaling+0x20>
      {
        return HAL_TIMEOUT;
 8000542:	2003      	movs	r0, #3
    }
  }
#endif  
  
  return HAL_OK;
}  
 8000544:	4770      	bx	lr
 8000546:	bf00      	nop
 8000548:	40007000 	.word	0x40007000
 800054c:	20000000 	.word	0x20000000
 8000550:	431bde83 	.word	0x431bde83

08000554 <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  msirange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
 8000554:	b530      	push	{r4, r5, lr}
  uint32_t vos = 0;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */

  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 8000556:	4d20      	ldr	r5, [pc, #128]	; (80005d8 <RCC_SetFlashLatencyFromMSIRange+0x84>)
 8000558:	6dab      	ldr	r3, [r5, #88]	; 0x58
 800055a:	00db      	lsls	r3, r3, #3
            voltage range.
  * @param  msirange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
 800055c:	b083      	sub	sp, #12
 800055e:	4604      	mov	r4, r0
  uint32_t vos = 0;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */

  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 8000560:	d51a      	bpl.n	8000598 <RCC_SetFlashLatencyFromMSIRange+0x44>
  {
    vos = HAL_PWREx_GetVoltageRange();
 8000562:	f7ff ffb3 	bl	80004cc <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_ENABLE();
    vos = HAL_PWREx_GetVoltageRange();
    __HAL_RCC_PWR_CLK_DISABLE();
  }

  if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
 8000566:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 800056a:	d027      	beq.n	80005bc <RCC_SetFlashLatencyFromMSIRange+0x68>
        latency = FLASH_LATENCY_1; /* 1WS */
      }
      /* else MSI < 8Mhz default FLASH_LATENCY_0 0WS */
    }
#else
    if(msirange > RCC_MSIRANGE_8)
 800056c:	2c80      	cmp	r4, #128	; 0x80
 800056e:	d82c      	bhi.n	80005ca <RCC_SetFlashLatencyFromMSIRange+0x76>
      /* MSI > 16Mhz */
      latency = FLASH_LATENCY_3; /* 3WS */
    }
    else
    {
      if(msirange == RCC_MSIRANGE_8)
 8000570:	d02f      	beq.n	80005d2 <RCC_SetFlashLatencyFromMSIRange+0x7e>
    {
      /* MSI > 16Mhz */
      if(msirange > RCC_MSIRANGE_10)
      {
        /* MSI 48Mhz */
        latency = FLASH_LATENCY_2; /* 2WS */
 8000572:	f1a4 0270 	sub.w	r2, r4, #112	; 0x70
 8000576:	fab2 f282 	clz	r2, r2
 800057a:	0952      	lsrs	r2, r2, #5
      /* else MSI < 8Mhz default FLASH_LATENCY_0 0WS */
    }
#endif
  }

  __HAL_FLASH_SET_LATENCY(latency);
 800057c:	4917      	ldr	r1, [pc, #92]	; (80005dc <RCC_SetFlashLatencyFromMSIRange+0x88>)
 800057e:	680b      	ldr	r3, [r1, #0]
 8000580:	f023 0307 	bic.w	r3, r3, #7
 8000584:	4313      	orrs	r3, r2
 8000586:	600b      	str	r3, [r1, #0]

  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  if(READ_BIT(FLASH->ACR, FLASH_ACR_LATENCY) != latency)
 8000588:	6808      	ldr	r0, [r1, #0]
 800058a:	f000 0007 	and.w	r0, r0, #7
  {
    return HAL_ERROR;
  }

  return HAL_OK;
}
 800058e:	1a80      	subs	r0, r0, r2
 8000590:	bf18      	it	ne
 8000592:	2001      	movne	r0, #1
 8000594:	b003      	add	sp, #12
 8000596:	bd30      	pop	{r4, r5, pc}
  {
    vos = HAL_PWREx_GetVoltageRange();
  }
  else
  {
    __HAL_RCC_PWR_CLK_ENABLE();
 8000598:	6dab      	ldr	r3, [r5, #88]	; 0x58
 800059a:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800059e:	65ab      	str	r3, [r5, #88]	; 0x58
 80005a0:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80005a2:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80005a6:	9301      	str	r3, [sp, #4]
 80005a8:	9b01      	ldr	r3, [sp, #4]
    vos = HAL_PWREx_GetVoltageRange();
 80005aa:	f7ff ff8f 	bl	80004cc <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_DISABLE();
 80005ae:	6dab      	ldr	r3, [r5, #88]	; 0x58
  }

  if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
 80005b0:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
  }
  else
  {
    __HAL_RCC_PWR_CLK_ENABLE();
    vos = HAL_PWREx_GetVoltageRange();
    __HAL_RCC_PWR_CLK_DISABLE();
 80005b4:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80005b8:	65ab      	str	r3, [r5, #88]	; 0x58
  }

  if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
 80005ba:	d1d7      	bne.n	800056c <RCC_SetFlashLatencyFromMSIRange+0x18>
  {
    if(msirange > RCC_MSIRANGE_8)
 80005bc:	2c80      	cmp	r4, #128	; 0x80
 80005be:	d906      	bls.n	80005ce <RCC_SetFlashLatencyFromMSIRange+0x7a>
    {
      /* MSI > 16Mhz */
      if(msirange > RCC_MSIRANGE_10)
 80005c0:	2ca0      	cmp	r4, #160	; 0xa0
        latency = FLASH_LATENCY_2; /* 2WS */
      }
      else
      {
        /* MSI 24Mhz or 32Mhz */
        latency = FLASH_LATENCY_1; /* 1WS */
 80005c2:	bf8c      	ite	hi
 80005c4:	2202      	movhi	r2, #2
 80005c6:	2201      	movls	r2, #1
 80005c8:	e7d8      	b.n	800057c <RCC_SetFlashLatencyFromMSIRange+0x28>
    }
#else
    if(msirange > RCC_MSIRANGE_8)
    {
      /* MSI > 16Mhz */
      latency = FLASH_LATENCY_3; /* 3WS */
 80005ca:	2203      	movs	r2, #3
 80005cc:	e7d6      	b.n	800057c <RCC_SetFlashLatencyFromMSIRange+0x28>
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
  uint32_t vos = 0;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
 80005ce:	2200      	movs	r2, #0
 80005d0:	e7d4      	b.n	800057c <RCC_SetFlashLatencyFromMSIRange+0x28>
    {
      /* MSI > 16Mhz */
      if(msirange > RCC_MSIRANGE_10)
      {
        /* MSI 48Mhz */
        latency = FLASH_LATENCY_2; /* 2WS */
 80005d2:	2202      	movs	r2, #2
 80005d4:	e7d2      	b.n	800057c <RCC_SetFlashLatencyFromMSIRange+0x28>
 80005d6:	bf00      	nop
 80005d8:	40021000 	.word	0x40021000
 80005dc:	40022000 	.word	0x40022000

080005e0 <HAL_RCC_GetSysClockFreq>:
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t msirange = 0U, pllvco = 0U, pllsource = 0U, pllr = 2U, pllm = 2U;
  uint32_t sysclockfreq = 0U;

  if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) ||
 80005e0:	4b3a      	ldr	r3, [pc, #232]	; (80006cc <HAL_RCC_GetSysClockFreq+0xec>)
 80005e2:	689a      	ldr	r2, [r3, #8]
 80005e4:	f012 0f0c 	tst.w	r2, #12
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 80005e8:	b430      	push	{r4, r5}
  uint32_t msirange = 0U, pllvco = 0U, pllsource = 0U, pllr = 2U, pllm = 2U;
  uint32_t sysclockfreq = 0U;

  if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) ||
 80005ea:	d039      	beq.n	8000660 <HAL_RCC_GetSysClockFreq+0x80>
     ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)))
 80005ec:	689a      	ldr	r2, [r3, #8]
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t msirange = 0U, pllvco = 0U, pllsource = 0U, pllr = 2U, pllm = 2U;
  uint32_t sysclockfreq = 0U;

  if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) ||
 80005ee:	f002 020c 	and.w	r2, r2, #12
 80005f2:	2a0c      	cmp	r2, #12
 80005f4:	d02f      	beq.n	8000656 <HAL_RCC_GetSysClockFreq+0x76>
    {
      /* MSI used as system clock source */
      sysclockfreq = msirange;
    }
  }
  else if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)
 80005f6:	4a35      	ldr	r2, [pc, #212]	; (80006cc <HAL_RCC_GetSysClockFreq+0xec>)
 80005f8:	6893      	ldr	r3, [r2, #8]
 80005fa:	f003 030c 	and.w	r3, r3, #12
 80005fe:	2b04      	cmp	r3, #4
 8000600:	d055      	beq.n	80006ae <HAL_RCC_GetSysClockFreq+0xce>
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
  }
  else if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)
 8000602:	6893      	ldr	r3, [r2, #8]
 8000604:	f003 030c 	and.w	r3, r3, #12
 8000608:	2b08      	cmp	r3, #8
 800060a:	d05c      	beq.n	80006c6 <HAL_RCC_GetSysClockFreq+0xe6>
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
  }

  if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL)
 800060c:	4c2f      	ldr	r4, [pc, #188]	; (80006cc <HAL_RCC_GetSysClockFreq+0xec>)
 800060e:	68a1      	ldr	r1, [r4, #8]
 8000610:	f001 010c 	and.w	r1, r1, #12
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t msirange = 0U, pllvco = 0U, pllsource = 0U, pllr = 2U, pllm = 2U;
  uint32_t sysclockfreq = 0U;
 8000614:	2000      	movs	r0, #0
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
  }

  if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL)
 8000616:	290c      	cmp	r1, #12
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t msirange = 0U, pllvco = 0U, pllsource = 0U, pllr = 2U, pllm = 2U;
 8000618:	4605      	mov	r5, r0
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
  }

  if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL)
 800061a:	d13d      	bne.n	8000698 <HAL_RCC_GetSysClockFreq+0xb8>
    /* PLL used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 800061c:	68e1      	ldr	r1, [r4, #12]
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 800061e:	68e2      	ldr	r2, [r4, #12]

    switch (pllsource)
 8000620:	f001 0103 	and.w	r1, r1, #3

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8000624:	f3c2 1202 	ubfx	r2, r2, #4, #3

    switch (pllsource)
 8000628:	2902      	cmp	r1, #2

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 800062a:	f102 0301 	add.w	r3, r2, #1

    switch (pllsource)
 800062e:	d041      	beq.n	80006b4 <HAL_RCC_GetSysClockFreq+0xd4>
 8000630:	2903      	cmp	r1, #3
 8000632:	d033      	beq.n	800069c <HAL_RCC_GetSysClockFreq+0xbc>
      pllvco = (HSE_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
      break;

    case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
    default:
      pllvco = (msirange / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8000634:	fbb5 f3f3 	udiv	r3, r5, r3
 8000638:	68e2      	ldr	r2, [r4, #12]
 800063a:	f3c2 2206 	ubfx	r2, r2, #8, #7
 800063e:	fb03 f302 	mul.w	r3, r3, r2
      break;
    }
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8000642:	4a22      	ldr	r2, [pc, #136]	; (80006cc <HAL_RCC_GetSysClockFreq+0xec>)
 8000644:	68d0      	ldr	r0, [r2, #12]
    sysclockfreq = pllvco/pllr;
 8000646:	f3c0 6041 	ubfx	r0, r0, #25, #2
 800064a:	3001      	adds	r0, #1
 800064c:	0040      	lsls	r0, r0, #1
  }

  return sysclockfreq;
}
 800064e:	bc30      	pop	{r4, r5}
    default:
      pllvco = (msirange / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
      break;
    }
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
    sysclockfreq = pllvco/pllr;
 8000650:	fbb3 f0f0 	udiv	r0, r3, r0
  }

  return sysclockfreq;
}
 8000654:	4770      	bx	lr
{
  uint32_t msirange = 0U, pllvco = 0U, pllsource = 0U, pllr = 2U, pllm = 2U;
  uint32_t sysclockfreq = 0U;

  if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) ||
     ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)))
 8000656:	68db      	ldr	r3, [r3, #12]
 8000658:	f003 0303 	and.w	r3, r3, #3
 800065c:	2b01      	cmp	r3, #1
 800065e:	d1ca      	bne.n	80005f6 <HAL_RCC_GetSysClockFreq+0x16>
  {
    /* MSI or PLL with MSI source used as system clock source */

    /* Get SYSCLK source */
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == RESET)
 8000660:	4b1a      	ldr	r3, [pc, #104]	; (80006cc <HAL_RCC_GetSysClockFreq+0xec>)
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];
 8000662:	491b      	ldr	r1, [pc, #108]	; (80006d0 <HAL_RCC_GetSysClockFreq+0xf0>)
     ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)))
  {
    /* MSI or PLL with MSI source used as system clock source */

    /* Get SYSCLK source */
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == RESET)
 8000664:	681a      	ldr	r2, [r3, #0]
 8000666:	0712      	lsls	r2, r2, #28
    { /* MSISRANGE from RCC_CSR applies */
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 8000668:	bf54      	ite	pl
 800066a:	f8d3 3094 	ldrpl.w	r3, [r3, #148]	; 0x94
    }
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 800066e:	681b      	ldrmi	r3, [r3, #0]
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];

    if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI)
 8000670:	4a16      	ldr	r2, [pc, #88]	; (80006cc <HAL_RCC_GetSysClockFreq+0xec>)
    /* MSI or PLL with MSI source used as system clock source */

    /* Get SYSCLK source */
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == RESET)
    { /* MSISRANGE from RCC_CSR applies */
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 8000672:	bf54      	ite	pl
 8000674:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
    }
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 8000678:	f3c3 1303 	ubfxmi	r3, r3, #4, #4
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];

    if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI)
 800067c:	6892      	ldr	r2, [r2, #8]
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];
 800067e:	f851 5023 	ldr.w	r5, [r1, r3, lsl #2]

    if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI)
    {
      /* MSI used as system clock source */
      sysclockfreq = msirange;
 8000682:	f012 0f0c 	tst.w	r2, #12
 8000686:	bf0c      	ite	eq
 8000688:	4628      	moveq	r0, r5
 800068a:	2000      	movne	r0, #0
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
  }

  if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL)
 800068c:	4c0f      	ldr	r4, [pc, #60]	; (80006cc <HAL_RCC_GetSysClockFreq+0xec>)
 800068e:	68a1      	ldr	r1, [r4, #8]
 8000690:	f001 010c 	and.w	r1, r1, #12
 8000694:	290c      	cmp	r1, #12
 8000696:	d0c1      	beq.n	800061c <HAL_RCC_GetSysClockFreq+0x3c>
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
    sysclockfreq = pllvco/pllr;
  }

  return sysclockfreq;
}
 8000698:	bc30      	pop	{r4, r5}
 800069a:	4770      	bx	lr
    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
      pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
      break;

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pllvco = (HSE_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 800069c:	68e0      	ldr	r0, [r4, #12]
 800069e:	4a0d      	ldr	r2, [pc, #52]	; (80006d4 <HAL_RCC_GetSysClockFreq+0xf4>)
 80006a0:	fbb2 f2f3 	udiv	r2, r2, r3
 80006a4:	f3c0 2006 	ubfx	r0, r0, #8, #7
 80006a8:	fb02 f300 	mul.w	r3, r2, r0
      break;
 80006ac:	e7c9      	b.n	8000642 <HAL_RCC_GetSysClockFreq+0x62>
    }
  }
  else if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
 80006ae:	480a      	ldr	r0, [pc, #40]	; (80006d8 <HAL_RCC_GetSysClockFreq+0xf8>)
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t msirange = 0U, pllvco = 0U, pllsource = 0U, pllr = 2U, pllm = 2U;
 80006b0:	2500      	movs	r5, #0
 80006b2:	e7eb      	b.n	800068c <HAL_RCC_GetSysClockFreq+0xac>
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;

    switch (pllsource)
    {
    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
      pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 80006b4:	68e0      	ldr	r0, [r4, #12]
 80006b6:	4908      	ldr	r1, [pc, #32]	; (80006d8 <HAL_RCC_GetSysClockFreq+0xf8>)
 80006b8:	fbb1 f2f3 	udiv	r2, r1, r3
 80006bc:	f3c0 2006 	ubfx	r0, r0, #8, #7
 80006c0:	fb02 f300 	mul.w	r3, r2, r0
      break;
 80006c4:	e7bd      	b.n	8000642 <HAL_RCC_GetSysClockFreq+0x62>
    sysclockfreq = HSI_VALUE;
  }
  else if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
 80006c6:	4803      	ldr	r0, [pc, #12]	; (80006d4 <HAL_RCC_GetSysClockFreq+0xf4>)
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t msirange = 0U, pllvco = 0U, pllsource = 0U, pllr = 2U, pllm = 2U;
 80006c8:	2500      	movs	r5, #0
 80006ca:	e7df      	b.n	800068c <HAL_RCC_GetSysClockFreq+0xac>
 80006cc:	40021000 	.word	0x40021000
 80006d0:	08001af0 	.word	0x08001af0
 80006d4:	007a1200 	.word	0x007a1200
 80006d8:	00f42400 	.word	0x00f42400

080006dc <HAL_RCC_OscConfig>:
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 80006dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*----------------------------- MSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 80006e0:	6803      	ldr	r3, [r0, #0]
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 80006e2:	4605      	mov	r5, r0
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*----------------------------- MSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 80006e4:	06d8      	lsls	r0, r3, #27
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 80006e6:	b082      	sub	sp, #8
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*----------------------------- MSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 80006e8:	d557      	bpl.n	800079a <HAL_RCC_OscConfig+0xbe>
    assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));
    assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
    assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

    /* When the MSI is used as system clock it will not be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) )
 80006ea:	4bb4      	ldr	r3, [pc, #720]	; (80009bc <HAL_RCC_OscConfig+0x2e0>)
 80006ec:	689a      	ldr	r2, [r3, #8]
 80006ee:	f012 0f0c 	tst.w	r2, #12
 80006f2:	f040 8157 	bne.w	80009a4 <HAL_RCC_OscConfig+0x2c8>
    {
      if((READ_BIT(RCC->CR, RCC_CR_MSIRDY) != RESET) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 80006f6:	681b      	ldr	r3, [r3, #0]
 80006f8:	0799      	lsls	r1, r3, #30
 80006fa:	d503      	bpl.n	8000704 <HAL_RCC_OscConfig+0x28>
 80006fc:	69ab      	ldr	r3, [r5, #24]
 80006fe:	2b00      	cmp	r3, #0
 8000700:	f000 81c9 	beq.w	8000a96 <HAL_RCC_OscConfig+0x3ba>
      else
      {
        /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
           must be correctly programmed according to the frequency of the CPU clock
           (HCLK) and the supply voltage of the device. */
        if(RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 8000704:	4bad      	ldr	r3, [pc, #692]	; (80009bc <HAL_RCC_OscConfig+0x2e0>)
 8000706:	6a28      	ldr	r0, [r5, #32]
 8000708:	681a      	ldr	r2, [r3, #0]
 800070a:	0712      	lsls	r2, r2, #28
 800070c:	bf56      	itet	pl
 800070e:	f8d3 3094 	ldrpl.w	r3, [r3, #148]	; 0x94
 8000712:	681b      	ldrmi	r3, [r3, #0]
 8000714:	091b      	lsrpl	r3, r3, #4
 8000716:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800071a:	4283      	cmp	r3, r0
 800071c:	d217      	bcs.n	800074e <HAL_RCC_OscConfig+0x72>
        {
          /* First increase number of wait states update if necessary */
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 800071e:	f7ff ff19 	bl	8000554 <RCC_SetFlashLatencyFromMSIRange>
 8000722:	2800      	cmp	r0, #0
 8000724:	f040 81b7 	bne.w	8000a96 <HAL_RCC_OscConfig+0x3ba>
          {
            return HAL_ERROR;
          }

          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8000728:	4ba4      	ldr	r3, [pc, #656]	; (80009bc <HAL_RCC_OscConfig+0x2e0>)
 800072a:	681a      	ldr	r2, [r3, #0]
 800072c:	f042 0208 	orr.w	r2, r2, #8
 8000730:	601a      	str	r2, [r3, #0]
 8000732:	6819      	ldr	r1, [r3, #0]
 8000734:	6a2a      	ldr	r2, [r5, #32]
 8000736:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
 800073a:	430a      	orrs	r2, r1
 800073c:	601a      	str	r2, [r3, #0]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 800073e:	685a      	ldr	r2, [r3, #4]
 8000740:	69e9      	ldr	r1, [r5, #28]
 8000742:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 8000746:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 800074a:	605a      	str	r2, [r3, #4]
 800074c:	e015      	b.n	800077a <HAL_RCC_OscConfig+0x9e>
        }
        else
        {
          /* Else, keep current flash latency while decreasing applies */
          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 800074e:	4b9b      	ldr	r3, [pc, #620]	; (80009bc <HAL_RCC_OscConfig+0x2e0>)
 8000750:	681a      	ldr	r2, [r3, #0]
 8000752:	f042 0208 	orr.w	r2, r2, #8
 8000756:	601a      	str	r2, [r3, #0]
 8000758:	681a      	ldr	r2, [r3, #0]
 800075a:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 800075e:	4302      	orrs	r2, r0
 8000760:	601a      	str	r2, [r3, #0]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8000762:	685a      	ldr	r2, [r3, #4]
 8000764:	69e9      	ldr	r1, [r5, #28]
 8000766:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 800076a:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 800076e:	605a      	str	r2, [r3, #4]

          /* Decrease number of wait states update if necessary */
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8000770:	f7ff fef0 	bl	8000554 <RCC_SetFlashLatencyFromMSIRange>
 8000774:	2800      	cmp	r0, #0
 8000776:	f040 818e 	bne.w	8000a96 <HAL_RCC_OscConfig+0x3ba>
            return HAL_ERROR;
          }
        }

        /* Update the SystemCoreClock global variable */
        SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 800077a:	f7ff ff31 	bl	80005e0 <HAL_RCC_GetSysClockFreq>
 800077e:	4b8f      	ldr	r3, [pc, #572]	; (80009bc <HAL_RCC_OscConfig+0x2e0>)
 8000780:	498f      	ldr	r1, [pc, #572]	; (80009c0 <HAL_RCC_OscConfig+0x2e4>)
 8000782:	689b      	ldr	r3, [r3, #8]
 8000784:	4a8f      	ldr	r2, [pc, #572]	; (80009c4 <HAL_RCC_OscConfig+0x2e8>)
 8000786:	f3c3 1303 	ubfx	r3, r3, #4, #4
 800078a:	5ccb      	ldrb	r3, [r1, r3]
 800078c:	fa20 f303 	lsr.w	r3, r0, r3

        /* Configure the source of time base considering new system clocks settings*/
        HAL_InitTick (TICK_INT_PRIORITY);
 8000790:	2000      	movs	r0, #0
            return HAL_ERROR;
          }
        }

        /* Update the SystemCoreClock global variable */
        SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 8000792:	6013      	str	r3, [r2, #0]

        /* Configure the source of time base considering new system clocks settings*/
        HAL_InitTick (TICK_INT_PRIORITY);
 8000794:	f7ff fd1a 	bl	80001cc <HAL_InitTick>
 8000798:	682b      	ldr	r3, [r5, #0]
        }
      }
    }
  }
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800079a:	07d9      	lsls	r1, r3, #31
 800079c:	d52f      	bpl.n	80007fe <HAL_RCC_OscConfig+0x122>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||
 800079e:	4987      	ldr	r1, [pc, #540]	; (80009bc <HAL_RCC_OscConfig+0x2e0>)
 80007a0:	688a      	ldr	r2, [r1, #8]
 80007a2:	f002 020c 	and.w	r2, r2, #12
 80007a6:	2a08      	cmp	r2, #8
 80007a8:	f000 816c 	beq.w	8000a84 <HAL_RCC_OscConfig+0x3a8>
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 80007ac:	688a      	ldr	r2, [r1, #8]
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||
 80007ae:	f002 020c 	and.w	r2, r2, #12
 80007b2:	2a0c      	cmp	r2, #12
 80007b4:	f000 8160 	beq.w	8000a78 <HAL_RCC_OscConfig+0x39c>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80007b8:	686b      	ldr	r3, [r5, #4]
 80007ba:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80007be:	f000 816e 	beq.w	8000a9e <HAL_RCC_OscConfig+0x3c2>
 80007c2:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 80007c6:	f000 81dc 	beq.w	8000b82 <HAL_RCC_OscConfig+0x4a6>
 80007ca:	4c7c      	ldr	r4, [pc, #496]	; (80009bc <HAL_RCC_OscConfig+0x2e0>)
 80007cc:	6822      	ldr	r2, [r4, #0]
 80007ce:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80007d2:	6022      	str	r2, [r4, #0]
 80007d4:	6822      	ldr	r2, [r4, #0]
 80007d6:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80007da:	6022      	str	r2, [r4, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 80007dc:	2b00      	cmp	r3, #0
 80007de:	f040 8163 	bne.w	8000aa8 <HAL_RCC_OscConfig+0x3cc>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80007e2:	f7ff fd1d 	bl	8000220 <HAL_GetTick>
 80007e6:	4606      	mov	r6, r0

        /* Wait till HSE is disabled */
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) != RESET)
 80007e8:	e005      	b.n	80007f6 <HAL_RCC_OscConfig+0x11a>
        {
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80007ea:	f7ff fd19 	bl	8000220 <HAL_GetTick>
 80007ee:	1b80      	subs	r0, r0, r6
 80007f0:	2864      	cmp	r0, #100	; 0x64
 80007f2:	f200 818d 	bhi.w	8000b10 <HAL_RCC_OscConfig+0x434>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSE is disabled */
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) != RESET)
 80007f6:	6823      	ldr	r3, [r4, #0]
 80007f8:	039f      	lsls	r7, r3, #14
 80007fa:	d4f6      	bmi.n	80007ea <HAL_RCC_OscConfig+0x10e>
 80007fc:	682b      	ldr	r3, [r5, #0]
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80007fe:	079e      	lsls	r6, r3, #30
 8000800:	d52b      	bpl.n	800085a <HAL_RCC_OscConfig+0x17e>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||
 8000802:	496e      	ldr	r1, [pc, #440]	; (80009bc <HAL_RCC_OscConfig+0x2e0>)
 8000804:	688a      	ldr	r2, [r1, #8]
 8000806:	f002 020c 	and.w	r2, r2, #12
 800080a:	2a04      	cmp	r2, #4
 800080c:	f000 8160 	beq.w	8000ad0 <HAL_RCC_OscConfig+0x3f4>
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
 8000810:	688a      	ldr	r2, [r1, #8]
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||
 8000812:	f002 020c 	and.w	r2, r2, #12
 8000816:	2a0c      	cmp	r2, #12
 8000818:	f000 8154 	beq.w	8000ac4 <HAL_RCC_OscConfig+0x3e8>
      }
    }
    else
    {
      /* Check the HSI State */
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 800081c:	68eb      	ldr	r3, [r5, #12]
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 800081e:	4c67      	ldr	r4, [pc, #412]	; (80009bc <HAL_RCC_OscConfig+0x2e0>)
      }
    }
    else
    {
      /* Check the HSI State */
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8000820:	2b00      	cmp	r3, #0
 8000822:	f000 8117 	beq.w	8000a54 <HAL_RCC_OscConfig+0x378>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8000826:	6823      	ldr	r3, [r4, #0]
 8000828:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800082c:	6023      	str	r3, [r4, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800082e:	f7ff fcf7 	bl	8000220 <HAL_GetTick>
 8000832:	4606      	mov	r6, r0

        /* Wait till HSI is ready */
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == RESET)
 8000834:	e005      	b.n	8000842 <HAL_RCC_OscConfig+0x166>
        {
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8000836:	f7ff fcf3 	bl	8000220 <HAL_GetTick>
 800083a:	1b80      	subs	r0, r0, r6
 800083c:	2802      	cmp	r0, #2
 800083e:	f200 8167 	bhi.w	8000b10 <HAL_RCC_OscConfig+0x434>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSI is ready */
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == RESET)
 8000842:	6823      	ldr	r3, [r4, #0]
 8000844:	4a5d      	ldr	r2, [pc, #372]	; (80009bc <HAL_RCC_OscConfig+0x2e0>)
 8000846:	0558      	lsls	r0, r3, #21
 8000848:	d5f5      	bpl.n	8000836 <HAL_RCC_OscConfig+0x15a>
            return HAL_TIMEOUT;
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800084a:	6853      	ldr	r3, [r2, #4]
 800084c:	6929      	ldr	r1, [r5, #16]
 800084e:	f023 53f8 	bic.w	r3, r3, #520093696	; 0x1f000000
 8000852:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 8000856:	6053      	str	r3, [r2, #4]
 8000858:	682b      	ldr	r3, [r5, #0]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800085a:	071a      	lsls	r2, r3, #28
 800085c:	d519      	bpl.n	8000892 <HAL_RCC_OscConfig+0x1b6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 800085e:	696b      	ldr	r3, [r5, #20]
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8000860:	4c56      	ldr	r4, [pc, #344]	; (80009bc <HAL_RCC_OscConfig+0x2e0>)
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8000862:	2b00      	cmp	r3, #0
 8000864:	f000 80e2 	beq.w	8000a2c <HAL_RCC_OscConfig+0x350>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8000868:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 800086c:	f043 0301 	orr.w	r3, r3, #1
 8000870:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8000874:	f7ff fcd4 	bl	8000220 <HAL_GetTick>
 8000878:	4606      	mov	r6, r0

      /* Wait till LSI is ready */
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == RESET)
 800087a:	e005      	b.n	8000888 <HAL_RCC_OscConfig+0x1ac>
      {
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 800087c:	f7ff fcd0 	bl	8000220 <HAL_GetTick>
 8000880:	1b80      	subs	r0, r0, r6
 8000882:	2802      	cmp	r0, #2
 8000884:	f200 8144 	bhi.w	8000b10 <HAL_RCC_OscConfig+0x434>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSI is ready */
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == RESET)
 8000888:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 800088c:	079b      	lsls	r3, r3, #30
 800088e:	d5f5      	bpl.n	800087c <HAL_RCC_OscConfig+0x1a0>
 8000890:	682b      	ldr	r3, [r5, #0]
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8000892:	0758      	lsls	r0, r3, #29
 8000894:	d53f      	bpl.n	8000916 <HAL_RCC_OscConfig+0x23a>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(HAL_IS_BIT_CLR(RCC->APB1ENR1, RCC_APB1ENR1_PWREN))
 8000896:	4b49      	ldr	r3, [pc, #292]	; (80009bc <HAL_RCC_OscConfig+0x2e0>)
 8000898:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800089a:	00d1      	lsls	r1, r2, #3
 800089c:	f100 813c 	bmi.w	8000b18 <HAL_RCC_OscConfig+0x43c>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 80008a0:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80008a2:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80008a6:	659a      	str	r2, [r3, #88]	; 0x58
 80008a8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80008aa:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80008ae:	9301      	str	r3, [sp, #4]
 80008b0:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 80008b2:	2601      	movs	r6, #1
    }

    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 80008b4:	4c44      	ldr	r4, [pc, #272]	; (80009c8 <HAL_RCC_OscConfig+0x2ec>)
 80008b6:	6823      	ldr	r3, [r4, #0]
 80008b8:	05da      	lsls	r2, r3, #23
 80008ba:	f140 8119 	bpl.w	8000af0 <HAL_RCC_OscConfig+0x414>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80008be:	68ab      	ldr	r3, [r5, #8]
 80008c0:	2b01      	cmp	r3, #1
 80008c2:	f000 8170 	beq.w	8000ba6 <HAL_RCC_OscConfig+0x4ca>
 80008c6:	2b05      	cmp	r3, #5
 80008c8:	f000 8128 	beq.w	8000b1c <HAL_RCC_OscConfig+0x440>
 80008cc:	4c3b      	ldr	r4, [pc, #236]	; (80009bc <HAL_RCC_OscConfig+0x2e0>)
 80008ce:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
 80008d2:	f022 0201 	bic.w	r2, r2, #1
 80008d6:	f8c4 2090 	str.w	r2, [r4, #144]	; 0x90
 80008da:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
 80008de:	f022 0204 	bic.w	r2, r2, #4
 80008e2:	f8c4 2090 	str.w	r2, [r4, #144]	; 0x90

    /* Check the LSE State */
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 80008e6:	2b00      	cmp	r3, #0
 80008e8:	f040 8125 	bne.w	8000b36 <HAL_RCC_OscConfig+0x45a>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80008ec:	f7ff fc98 	bl	8000220 <HAL_GetTick>

      /* Wait till LSE is disabled */
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != RESET)
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80008f0:	f241 3788 	movw	r7, #5000	; 0x1388
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80008f4:	4680      	mov	r8, r0

      /* Wait till LSE is disabled */
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != RESET)
 80008f6:	e006      	b.n	8000906 <HAL_RCC_OscConfig+0x22a>
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80008f8:	f7ff fc92 	bl	8000220 <HAL_GetTick>
 80008fc:	ebc8 0000 	rsb	r0, r8, r0
 8000900:	42b8      	cmp	r0, r7
 8000902:	f200 8105 	bhi.w	8000b10 <HAL_RCC_OscConfig+0x434>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSE is disabled */
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != RESET)
 8000906:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 800090a:	0799      	lsls	r1, r3, #30
 800090c:	d4f4      	bmi.n	80008f8 <HAL_RCC_OscConfig+0x21c>
        }
      }
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 800090e:	2e00      	cmp	r6, #0
 8000910:	f040 8151 	bne.w	8000bb6 <HAL_RCC_OscConfig+0x4da>
 8000914:	682b      	ldr	r3, [r5, #0]
      __HAL_RCC_PWR_CLK_DISABLE();
    }
  }
#if defined(RCC_HSI48_SUPPORT)
  /*------------------------------ HSI48 Configuration -----------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 8000916:	069a      	lsls	r2, r3, #26
 8000918:	d518      	bpl.n	800094c <HAL_RCC_OscConfig+0x270>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));

    /* Check the LSI State */
    if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 800091a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    {
      /* Enable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_ENABLE();
 800091c:	4c27      	ldr	r4, [pc, #156]	; (80009bc <HAL_RCC_OscConfig+0x2e0>)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));

    /* Check the LSI State */
    if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 800091e:	2b00      	cmp	r3, #0
 8000920:	f000 811b 	beq.w	8000b5a <HAL_RCC_OscConfig+0x47e>
    {
      /* Enable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_ENABLE();
 8000924:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 8000928:	f043 0301 	orr.w	r3, r3, #1
 800092c:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8000930:	f7ff fc76 	bl	8000220 <HAL_GetTick>
 8000934:	4606      	mov	r6, r0

      /* Wait till HSI48 is ready */
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == RESET)
 8000936:	e005      	b.n	8000944 <HAL_RCC_OscConfig+0x268>
      {
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8000938:	f7ff fc72 	bl	8000220 <HAL_GetTick>
 800093c:	1b80      	subs	r0, r0, r6
 800093e:	2802      	cmp	r0, #2
 8000940:	f200 80e6 	bhi.w	8000b10 <HAL_RCC_OscConfig+0x434>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till HSI48 is ready */
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == RESET)
 8000944:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 8000948:	079b      	lsls	r3, r3, #30
 800094a:	d5f5      	bpl.n	8000938 <HAL_RCC_OscConfig+0x25c>
#endif /* RCC_HSI48_SUPPORT */
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));

  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 800094c:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 800094e:	b32a      	cbz	r2, 800099c <HAL_RCC_OscConfig+0x2c0>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8000950:	4b1a      	ldr	r3, [pc, #104]	; (80009bc <HAL_RCC_OscConfig+0x2e0>)
 8000952:	6899      	ldr	r1, [r3, #8]
 8000954:	f001 010c 	and.w	r1, r1, #12
 8000958:	290c      	cmp	r1, #12
 800095a:	f000 809c 	beq.w	8000a96 <HAL_RCC_OscConfig+0x3ba>
    {
      if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 800095e:	2a02      	cmp	r2, #2
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8000960:	681a      	ldr	r2, [r3, #0]
 8000962:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 8000966:	601a      	str	r2, [r3, #0]
  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
    {
      if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 8000968:	f000 812b 	beq.w	8000bc2 <HAL_RCC_OscConfig+0x4e6>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();

        /* Disable all PLL outputs to save power if no PLLs on */
        if((READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == RESET)
 800096c:	681a      	ldr	r2, [r3, #0]
 800096e:	0112      	lsls	r2, r2, #4
 8000970:	f140 8114 	bpl.w	8000b9c <HAL_RCC_OscConfig+0x4c0>
        }

#if defined(RCC_PLLSAI2_SUPPORT)
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI3CLK);
#else
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI2CLK);
 8000974:	4c11      	ldr	r4, [pc, #68]	; (80009bc <HAL_RCC_OscConfig+0x2e0>)
 8000976:	68e3      	ldr	r3, [r4, #12]
 8000978:	f023 7388 	bic.w	r3, r3, #17825792	; 0x1100000
 800097c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8000980:	60e3      	str	r3, [r4, #12]
#endif /* RCC_PLLSAI2_SUPPORT */

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8000982:	f7ff fc4d 	bl	8000220 <HAL_GetTick>
 8000986:	4605      	mov	r5, r0

        /* Wait till PLL is disabled */
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RESET)
 8000988:	e005      	b.n	8000996 <HAL_RCC_OscConfig+0x2ba>
        {
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800098a:	f7ff fc49 	bl	8000220 <HAL_GetTick>
 800098e:	1b40      	subs	r0, r0, r5
 8000990:	2802      	cmp	r0, #2
 8000992:	f200 80bd 	bhi.w	8000b10 <HAL_RCC_OscConfig+0x434>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is disabled */
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RESET)
 8000996:	6823      	ldr	r3, [r4, #0]
 8000998:	019b      	lsls	r3, r3, #6
 800099a:	d4f6      	bmi.n	800098a <HAL_RCC_OscConfig+0x2ae>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 800099c:	2000      	movs	r0, #0
}
 800099e:	b002      	add	sp, #8
 80009a0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      }
    }
    else
    {
      /* Check the MSI State */
      if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 80009a4:	69aa      	ldr	r2, [r5, #24]
 80009a6:	b372      	cbz	r2, 8000a06 <HAL_RCC_OscConfig+0x32a>
      {
        /* Enable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
 80009a8:	681a      	ldr	r2, [r3, #0]
 80009aa:	f042 0201 	orr.w	r2, r2, #1
 80009ae:	601a      	str	r2, [r3, #0]

        /* Get timeout */
        tickstart = HAL_GetTick();

        /* Wait till MSI is ready */
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == RESET)
 80009b0:	461c      	mov	r4, r3
      {
        /* Enable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();

        /* Get timeout */
        tickstart = HAL_GetTick();
 80009b2:	f7ff fc35 	bl	8000220 <HAL_GetTick>
 80009b6:	4606      	mov	r6, r0

        /* Wait till MSI is ready */
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == RESET)
 80009b8:	e00e      	b.n	80009d8 <HAL_RCC_OscConfig+0x2fc>
 80009ba:	bf00      	nop
 80009bc:	40021000 	.word	0x40021000
 80009c0:	08001ae0 	.word	0x08001ae0
 80009c4:	20000000 	.word	0x20000000
 80009c8:	40007000 	.word	0x40007000
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 80009cc:	f7ff fc28 	bl	8000220 <HAL_GetTick>
 80009d0:	1b80      	subs	r0, r0, r6
 80009d2:	2802      	cmp	r0, #2
 80009d4:	f200 809c 	bhi.w	8000b10 <HAL_RCC_OscConfig+0x434>

        /* Get timeout */
        tickstart = HAL_GetTick();

        /* Wait till MSI is ready */
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == RESET)
 80009d8:	6823      	ldr	r3, [r4, #0]
 80009da:	4a97      	ldr	r2, [pc, #604]	; (8000c38 <HAL_RCC_OscConfig+0x55c>)
 80009dc:	079f      	lsls	r7, r3, #30
 80009de:	d5f5      	bpl.n	80009cc <HAL_RCC_OscConfig+0x2f0>
          {
            return HAL_TIMEOUT;
          }
        }
         /* Selects the Multiple Speed oscillator (MSI) clock range .*/
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 80009e0:	6813      	ldr	r3, [r2, #0]
 80009e2:	f043 0308 	orr.w	r3, r3, #8
 80009e6:	6013      	str	r3, [r2, #0]
 80009e8:	6811      	ldr	r1, [r2, #0]
 80009ea:	6a2b      	ldr	r3, [r5, #32]
 80009ec:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
 80009f0:	430b      	orrs	r3, r1
 80009f2:	6013      	str	r3, [r2, #0]
         /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 80009f4:	6853      	ldr	r3, [r2, #4]
 80009f6:	69e9      	ldr	r1, [r5, #28]
 80009f8:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 80009fc:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8000a00:	6053      	str	r3, [r2, #4]
 8000a02:	682b      	ldr	r3, [r5, #0]
 8000a04:	e6c9      	b.n	800079a <HAL_RCC_OscConfig+0xbe>

      }
      else
      {
        /* Disable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
 8000a06:	681a      	ldr	r2, [r3, #0]
 8000a08:	f022 0201 	bic.w	r2, r2, #1
 8000a0c:	601a      	str	r2, [r3, #0]

        /* Get timeout */
        tickstart = HAL_GetTick();

        /* Wait till MSI is ready */
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) != RESET)
 8000a0e:	461c      	mov	r4, r3
      {
        /* Disable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();

        /* Get timeout */
        tickstart = HAL_GetTick();
 8000a10:	f7ff fc06 	bl	8000220 <HAL_GetTick>
 8000a14:	4606      	mov	r6, r0

        /* Wait till MSI is ready */
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) != RESET)
 8000a16:	e004      	b.n	8000a22 <HAL_RCC_OscConfig+0x346>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8000a18:	f7ff fc02 	bl	8000220 <HAL_GetTick>
 8000a1c:	1b80      	subs	r0, r0, r6
 8000a1e:	2802      	cmp	r0, #2
 8000a20:	d876      	bhi.n	8000b10 <HAL_RCC_OscConfig+0x434>

        /* Get timeout */
        tickstart = HAL_GetTick();

        /* Wait till MSI is ready */
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) != RESET)
 8000a22:	6823      	ldr	r3, [r4, #0]
 8000a24:	0798      	lsls	r0, r3, #30
 8000a26:	d4f7      	bmi.n	8000a18 <HAL_RCC_OscConfig+0x33c>
 8000a28:	682b      	ldr	r3, [r5, #0]
 8000a2a:	e6b6      	b.n	800079a <HAL_RCC_OscConfig+0xbe>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8000a2c:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 8000a30:	f023 0301 	bic.w	r3, r3, #1
 8000a34:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8000a38:	f7ff fbf2 	bl	8000220 <HAL_GetTick>
 8000a3c:	4606      	mov	r6, r0

      /* Wait till LSI is disabled */
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != RESET)
 8000a3e:	e004      	b.n	8000a4a <HAL_RCC_OscConfig+0x36e>
      {
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8000a40:	f7ff fbee 	bl	8000220 <HAL_GetTick>
 8000a44:	1b80      	subs	r0, r0, r6
 8000a46:	2802      	cmp	r0, #2
 8000a48:	d862      	bhi.n	8000b10 <HAL_RCC_OscConfig+0x434>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSI is disabled */
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != RESET)
 8000a4a:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 8000a4e:	079f      	lsls	r7, r3, #30
 8000a50:	d4f6      	bmi.n	8000a40 <HAL_RCC_OscConfig+0x364>
 8000a52:	e71d      	b.n	8000890 <HAL_RCC_OscConfig+0x1b4>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 8000a54:	6823      	ldr	r3, [r4, #0]
 8000a56:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8000a5a:	6023      	str	r3, [r4, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8000a5c:	f7ff fbe0 	bl	8000220 <HAL_GetTick>
 8000a60:	4606      	mov	r6, r0

        /* Wait till HSI is disabled */
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) != RESET)
 8000a62:	e004      	b.n	8000a6e <HAL_RCC_OscConfig+0x392>
        {
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8000a64:	f7ff fbdc 	bl	8000220 <HAL_GetTick>
 8000a68:	1b80      	subs	r0, r0, r6
 8000a6a:	2802      	cmp	r0, #2
 8000a6c:	d850      	bhi.n	8000b10 <HAL_RCC_OscConfig+0x434>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSI is disabled */
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) != RESET)
 8000a6e:	6823      	ldr	r3, [r4, #0]
 8000a70:	0559      	lsls	r1, r3, #21
 8000a72:	d4f7      	bmi.n	8000a64 <HAL_RCC_OscConfig+0x388>
 8000a74:	682b      	ldr	r3, [r5, #0]
 8000a76:	e6f0      	b.n	800085a <HAL_RCC_OscConfig+0x17e>
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 8000a78:	68ca      	ldr	r2, [r1, #12]
 8000a7a:	f002 0203 	and.w	r2, r2, #3
 8000a7e:	2a03      	cmp	r2, #3
 8000a80:	f47f ae9a 	bne.w	80007b8 <HAL_RCC_OscConfig+0xdc>
    {
      if((READ_BIT(RCC->CR, RCC_CR_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8000a84:	4a6c      	ldr	r2, [pc, #432]	; (8000c38 <HAL_RCC_OscConfig+0x55c>)
 8000a86:	6812      	ldr	r2, [r2, #0]
 8000a88:	0392      	lsls	r2, r2, #14
 8000a8a:	f57f aeb8 	bpl.w	80007fe <HAL_RCC_OscConfig+0x122>
 8000a8e:	686a      	ldr	r2, [r5, #4]
 8000a90:	2a00      	cmp	r2, #0
 8000a92:	f47f aeb4 	bne.w	80007fe <HAL_RCC_OscConfig+0x122>
        }
      }
    }
    else
    {
      return HAL_ERROR;
 8000a96:	2001      	movs	r0, #1
    }
  }
  return HAL_OK;
}
 8000a98:	b002      	add	sp, #8
 8000a9a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8000a9e:	4a66      	ldr	r2, [pc, #408]	; (8000c38 <HAL_RCC_OscConfig+0x55c>)
 8000aa0:	6813      	ldr	r3, [r2, #0]
 8000aa2:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000aa6:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8000aa8:	f7ff fbba 	bl	8000220 <HAL_GetTick>

        /* Wait till HSE is ready */
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == RESET)
 8000aac:	4c62      	ldr	r4, [pc, #392]	; (8000c38 <HAL_RCC_OscConfig+0x55c>)

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8000aae:	4606      	mov	r6, r0

        /* Wait till HSE is ready */
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == RESET)
 8000ab0:	e004      	b.n	8000abc <HAL_RCC_OscConfig+0x3e0>
        {
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8000ab2:	f7ff fbb5 	bl	8000220 <HAL_GetTick>
 8000ab6:	1b80      	subs	r0, r0, r6
 8000ab8:	2864      	cmp	r0, #100	; 0x64
 8000aba:	d829      	bhi.n	8000b10 <HAL_RCC_OscConfig+0x434>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSE is ready */
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == RESET)
 8000abc:	6823      	ldr	r3, [r4, #0]
 8000abe:	039b      	lsls	r3, r3, #14
 8000ac0:	d5f7      	bpl.n	8000ab2 <HAL_RCC_OscConfig+0x3d6>
 8000ac2:	e69b      	b.n	80007fc <HAL_RCC_OscConfig+0x120>
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
 8000ac4:	68ca      	ldr	r2, [r1, #12]
 8000ac6:	f002 0203 	and.w	r2, r2, #3
 8000aca:	2a02      	cmp	r2, #2
 8000acc:	f47f aea6 	bne.w	800081c <HAL_RCC_OscConfig+0x140>
    {
      /* When HSI is used as system clock it will not be disabled */
      if((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 8000ad0:	4a59      	ldr	r2, [pc, #356]	; (8000c38 <HAL_RCC_OscConfig+0x55c>)
 8000ad2:	6812      	ldr	r2, [r2, #0]
 8000ad4:	0554      	lsls	r4, r2, #21
 8000ad6:	d502      	bpl.n	8000ade <HAL_RCC_OscConfig+0x402>
 8000ad8:	68ea      	ldr	r2, [r5, #12]
 8000ada:	2a00      	cmp	r2, #0
 8000adc:	d0db      	beq.n	8000a96 <HAL_RCC_OscConfig+0x3ba>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8000ade:	4956      	ldr	r1, [pc, #344]	; (8000c38 <HAL_RCC_OscConfig+0x55c>)
 8000ae0:	6928      	ldr	r0, [r5, #16]
 8000ae2:	684a      	ldr	r2, [r1, #4]
 8000ae4:	f022 52f8 	bic.w	r2, r2, #520093696	; 0x1f000000
 8000ae8:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
 8000aec:	604a      	str	r2, [r1, #4]
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
    {
      /* When HSI is used as system clock it will not be disabled */
      if((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 8000aee:	e6b4      	b.n	800085a <HAL_RCC_OscConfig+0x17e>
    }

    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8000af0:	6823      	ldr	r3, [r4, #0]
 8000af2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000af6:	6023      	str	r3, [r4, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 8000af8:	f7ff fb92 	bl	8000220 <HAL_GetTick>
 8000afc:	4607      	mov	r7, r0

      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8000afe:	6823      	ldr	r3, [r4, #0]
 8000b00:	05db      	lsls	r3, r3, #23
 8000b02:	f53f aedc 	bmi.w	80008be <HAL_RCC_OscConfig+0x1e2>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8000b06:	f7ff fb8b 	bl	8000220 <HAL_GetTick>
 8000b0a:	1bc0      	subs	r0, r0, r7
 8000b0c:	2802      	cmp	r0, #2
 8000b0e:	d9f6      	bls.n	8000afe <HAL_RCC_OscConfig+0x422>
        /* Wait till MSI is ready */
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == RESET)
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
          {
            return HAL_TIMEOUT;
 8000b10:	2003      	movs	r0, #3
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
}
 8000b12:	b002      	add	sp, #8
 8000b14:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
  {
    FlagStatus       pwrclkchanged = RESET;
 8000b18:	2600      	movs	r6, #0
 8000b1a:	e6cb      	b.n	80008b4 <HAL_RCC_OscConfig+0x1d8>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000b1c:	4b46      	ldr	r3, [pc, #280]	; (8000c38 <HAL_RCC_OscConfig+0x55c>)
 8000b1e:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8000b22:	f042 0204 	orr.w	r2, r2, #4
 8000b26:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
 8000b2a:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8000b2e:	f042 0201 	orr.w	r2, r2, #1
 8000b32:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90

    /* Check the LSE State */
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8000b36:	f7ff fb73 	bl	8000220 <HAL_GetTick>

      /* Wait till LSE is ready */
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == RESET)
 8000b3a:	4c3f      	ldr	r4, [pc, #252]	; (8000c38 <HAL_RCC_OscConfig+0x55c>)

    /* Check the LSE State */
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8000b3c:	4680      	mov	r8, r0

      /* Wait till LSE is ready */
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == RESET)
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8000b3e:	f241 3788 	movw	r7, #5000	; 0x1388
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSE is ready */
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == RESET)
 8000b42:	e005      	b.n	8000b50 <HAL_RCC_OscConfig+0x474>
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8000b44:	f7ff fb6c 	bl	8000220 <HAL_GetTick>
 8000b48:	ebc8 0000 	rsb	r0, r8, r0
 8000b4c:	42b8      	cmp	r0, r7
 8000b4e:	d8df      	bhi.n	8000b10 <HAL_RCC_OscConfig+0x434>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSE is ready */
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == RESET)
 8000b50:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 8000b54:	0798      	lsls	r0, r3, #30
 8000b56:	d5f5      	bpl.n	8000b44 <HAL_RCC_OscConfig+0x468>
 8000b58:	e6d9      	b.n	800090e <HAL_RCC_OscConfig+0x232>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_DISABLE();
 8000b5a:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 8000b5e:	f023 0301 	bic.w	r3, r3, #1
 8000b62:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8000b66:	f7ff fb5b 	bl	8000220 <HAL_GetTick>
 8000b6a:	4606      	mov	r6, r0

      /* Wait till HSI48 is disabled */
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != RESET)
 8000b6c:	e004      	b.n	8000b78 <HAL_RCC_OscConfig+0x49c>
      {
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8000b6e:	f7ff fb57 	bl	8000220 <HAL_GetTick>
 8000b72:	1b80      	subs	r0, r0, r6
 8000b74:	2802      	cmp	r0, #2
 8000b76:	d8cb      	bhi.n	8000b10 <HAL_RCC_OscConfig+0x434>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till HSI48 is disabled */
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != RESET)
 8000b78:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 8000b7c:	079f      	lsls	r7, r3, #30
 8000b7e:	d4f6      	bmi.n	8000b6e <HAL_RCC_OscConfig+0x492>
 8000b80:	e6e4      	b.n	800094c <HAL_RCC_OscConfig+0x270>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8000b82:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8000b86:	f5a3 333c 	sub.w	r3, r3, #192512	; 0x2f000
 8000b8a:	681a      	ldr	r2, [r3, #0]
 8000b8c:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8000b90:	601a      	str	r2, [r3, #0]
 8000b92:	681a      	ldr	r2, [r3, #0]
 8000b94:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8000b98:	601a      	str	r2, [r3, #0]
 8000b9a:	e785      	b.n	8000aa8 <HAL_RCC_OscConfig+0x3cc>
           &&
           (READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) == RESET)
#endif /* RCC_PLLSAI2_SUPPORT */
          )
        {
          MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
 8000b9c:	68da      	ldr	r2, [r3, #12]
 8000b9e:	f022 0203 	bic.w	r2, r2, #3
 8000ba2:	60da      	str	r2, [r3, #12]
 8000ba4:	e6e6      	b.n	8000974 <HAL_RCC_OscConfig+0x298>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000ba6:	4a24      	ldr	r2, [pc, #144]	; (8000c38 <HAL_RCC_OscConfig+0x55c>)
 8000ba8:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8000bac:	f043 0301 	orr.w	r3, r3, #1
 8000bb0:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
 8000bb4:	e7bf      	b.n	8000b36 <HAL_RCC_OscConfig+0x45a>
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8000bb6:	4a20      	ldr	r2, [pc, #128]	; (8000c38 <HAL_RCC_OscConfig+0x55c>)
 8000bb8:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8000bba:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8000bbe:	6593      	str	r3, [r2, #88]	; 0x58
 8000bc0:	e6a8      	b.n	8000914 <HAL_RCC_OscConfig+0x238>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is ready */
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RESET)
 8000bc2:	461c      	mov	r4, r3

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8000bc4:	f7ff fb2c 	bl	8000220 <HAL_GetTick>
 8000bc8:	4606      	mov	r6, r0

        /* Wait till PLL is ready */
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RESET)
 8000bca:	e004      	b.n	8000bd6 <HAL_RCC_OscConfig+0x4fa>
        {
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8000bcc:	f7ff fb28 	bl	8000220 <HAL_GetTick>
 8000bd0:	1b80      	subs	r0, r0, r6
 8000bd2:	2802      	cmp	r0, #2
 8000bd4:	d89c      	bhi.n	8000b10 <HAL_RCC_OscConfig+0x434>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is ready */
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RESET)
 8000bd6:	6823      	ldr	r3, [r4, #0]
 8000bd8:	4a17      	ldr	r2, [pc, #92]	; (8000c38 <HAL_RCC_OscConfig+0x55c>)
 8000bda:	0198      	lsls	r0, r3, #6
 8000bdc:	d4f6      	bmi.n	8000bcc <HAL_RCC_OscConfig+0x4f0>
            return HAL_TIMEOUT;
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8000bde:	f105 032c 	add.w	r3, r5, #44	; 0x2c
 8000be2:	cbc8      	ldmia	r3, {r3, r6, r7}
 8000be4:	6bac      	ldr	r4, [r5, #56]	; 0x38
 8000be6:	6be8      	ldr	r0, [r5, #60]	; 0x3c
 8000be8:	6c29      	ldr	r1, [r5, #64]	; 0x40
 8000bea:	06e4      	lsls	r4, r4, #27
 8000bec:	ea44 2407 	orr.w	r4, r4, r7, lsl #8
 8000bf0:	4323      	orrs	r3, r4
 8000bf2:	0840      	lsrs	r0, r0, #1
 8000bf4:	1e74      	subs	r4, r6, #1
 8000bf6:	ea43 1304 	orr.w	r3, r3, r4, lsl #4
 8000bfa:	3801      	subs	r0, #1
 8000bfc:	0849      	lsrs	r1, r1, #1
 8000bfe:	ea43 5340 	orr.w	r3, r3, r0, lsl #21
 8000c02:	3901      	subs	r1, #1
 8000c04:	ea43 6341 	orr.w	r3, r3, r1, lsl #25
 8000c08:	60d3      	str	r3, [r2, #12]
                             RCC_OscInitStruct->PLL.PLLP,
                             RCC_OscInitStruct->PLL.PLLQ,
                             RCC_OscInitStruct->PLL.PLLR);

        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 8000c0a:	6813      	ldr	r3, [r2, #0]
 8000c0c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8000c10:	6013      	str	r3, [r2, #0]

        /* Enable PLL System Clock output. */
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 8000c12:	68d3      	ldr	r3, [r2, #12]
 8000c14:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8000c18:	60d3      	str	r3, [r2, #12]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is ready */
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == RESET)
 8000c1a:	4614      	mov	r4, r2

        /* Enable PLL System Clock output. */
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8000c1c:	f7ff fb00 	bl	8000220 <HAL_GetTick>
 8000c20:	4605      	mov	r5, r0

        /* Wait till PLL is ready */
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == RESET)
 8000c22:	e005      	b.n	8000c30 <HAL_RCC_OscConfig+0x554>
        {
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8000c24:	f7ff fafc 	bl	8000220 <HAL_GetTick>
 8000c28:	1b40      	subs	r0, r0, r5
 8000c2a:	2802      	cmp	r0, #2
 8000c2c:	f63f af70 	bhi.w	8000b10 <HAL_RCC_OscConfig+0x434>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is ready */
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == RESET)
 8000c30:	6823      	ldr	r3, [r4, #0]
 8000c32:	0199      	lsls	r1, r3, #6
 8000c34:	d5f6      	bpl.n	8000c24 <HAL_RCC_OscConfig+0x548>
 8000c36:	e6b1      	b.n	800099c <HAL_RCC_OscConfig+0x2c0>
 8000c38:	40021000 	.word	0x40021000

08000c3c <HAL_RCC_ClockConfig>:
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > READ_BIT(FLASH->ACR, FLASH_ACR_LATENCY))
 8000c3c:	4a56      	ldr	r2, [pc, #344]	; (8000d98 <HAL_RCC_ClockConfig+0x15c>)
 8000c3e:	6813      	ldr	r3, [r2, #0]
 8000c40:	f003 0307 	and.w	r3, r3, #7
 8000c44:	428b      	cmp	r3, r1
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8000c46:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > READ_BIT(FLASH->ACR, FLASH_ACR_LATENCY))
 8000c4a:	d20c      	bcs.n	8000c66 <HAL_RCC_ClockConfig+0x2a>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8000c4c:	6813      	ldr	r3, [r2, #0]
 8000c4e:	f023 0307 	bic.w	r3, r3, #7
 8000c52:	430b      	orrs	r3, r1
 8000c54:	6013      	str	r3, [r2, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(READ_BIT(FLASH->ACR, FLASH_ACR_LATENCY) != FLatency)
 8000c56:	6813      	ldr	r3, [r2, #0]
 8000c58:	f003 0307 	and.w	r3, r3, #7
 8000c5c:	4299      	cmp	r1, r3
 8000c5e:	d002      	beq.n	8000c66 <HAL_RCC_ClockConfig+0x2a>
    {
      return HAL_ERROR;
 8000c60:	2001      	movs	r0, #1
 8000c62:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8000c66:	6803      	ldr	r3, [r0, #0]
 8000c68:	460c      	mov	r4, r1
 8000c6a:	07d9      	lsls	r1, r3, #31
 8000c6c:	4605      	mov	r5, r0
 8000c6e:	d43d      	bmi.n	8000cec <HAL_RCC_ClockConfig+0xb0>
      }
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8000c70:	0799      	lsls	r1, r3, #30
 8000c72:	d506      	bpl.n	8000c82 <HAL_RCC_ClockConfig+0x46>
  {
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8000c74:	4849      	ldr	r0, [pc, #292]	; (8000d9c <HAL_RCC_ClockConfig+0x160>)
 8000c76:	68aa      	ldr	r2, [r5, #8]
 8000c78:	6881      	ldr	r1, [r0, #8]
 8000c7a:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
 8000c7e:	430a      	orrs	r2, r1
 8000c80:	6082      	str	r2, [r0, #8]
    }
  }
#endif

  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < READ_BIT(FLASH->ACR, FLASH_ACR_LATENCY))
 8000c82:	4945      	ldr	r1, [pc, #276]	; (8000d98 <HAL_RCC_ClockConfig+0x15c>)
 8000c84:	680a      	ldr	r2, [r1, #0]
 8000c86:	f002 0207 	and.w	r2, r2, #7
 8000c8a:	4294      	cmp	r4, r2
 8000c8c:	d209      	bcs.n	8000ca2 <HAL_RCC_ClockConfig+0x66>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8000c8e:	680a      	ldr	r2, [r1, #0]
 8000c90:	f022 0207 	bic.w	r2, r2, #7
 8000c94:	4322      	orrs	r2, r4
 8000c96:	600a      	str	r2, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(READ_BIT(FLASH->ACR, FLASH_ACR_LATENCY) != FLatency)
 8000c98:	680a      	ldr	r2, [r1, #0]
 8000c9a:	f002 0207 	and.w	r2, r2, #7
 8000c9e:	4294      	cmp	r4, r2
 8000ca0:	d1de      	bne.n	8000c60 <HAL_RCC_ClockConfig+0x24>
      return HAL_ERROR;
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8000ca2:	075a      	lsls	r2, r3, #29
 8000ca4:	d506      	bpl.n	8000cb4 <HAL_RCC_ClockConfig+0x78>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8000ca6:	483d      	ldr	r0, [pc, #244]	; (8000d9c <HAL_RCC_ClockConfig+0x160>)
 8000ca8:	68ea      	ldr	r2, [r5, #12]
 8000caa:	6881      	ldr	r1, [r0, #8]
 8000cac:	f421 61e0 	bic.w	r1, r1, #1792	; 0x700
 8000cb0:	430a      	orrs	r2, r1
 8000cb2:	6082      	str	r2, [r0, #8]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8000cb4:	071b      	lsls	r3, r3, #28
 8000cb6:	d507      	bpl.n	8000cc8 <HAL_RCC_ClockConfig+0x8c>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8000cb8:	4a38      	ldr	r2, [pc, #224]	; (8000d9c <HAL_RCC_ClockConfig+0x160>)
 8000cba:	6929      	ldr	r1, [r5, #16]
 8000cbc:	6893      	ldr	r3, [r2, #8]
 8000cbe:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 8000cc2:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8000cc6:	6093      	str	r3, [r2, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 8000cc8:	f7ff fc8a 	bl	80005e0 <HAL_RCC_GetSysClockFreq>
 8000ccc:	4b33      	ldr	r3, [pc, #204]	; (8000d9c <HAL_RCC_ClockConfig+0x160>)
 8000cce:	4934      	ldr	r1, [pc, #208]	; (8000da0 <HAL_RCC_ClockConfig+0x164>)
 8000cd0:	689b      	ldr	r3, [r3, #8]
 8000cd2:	4a34      	ldr	r2, [pc, #208]	; (8000da4 <HAL_RCC_ClockConfig+0x168>)
 8000cd4:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8000cd8:	5ccb      	ldrb	r3, [r1, r3]
 8000cda:	fa20 f303 	lsr.w	r3, r0, r3

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
 8000cde:	2000      	movs	r0, #0
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 8000ce0:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
 8000ce2:	f7ff fa73 	bl	80001cc <HAL_InitTick>

  return HAL_OK;
 8000ce6:	2000      	movs	r0, #0
}
 8000ce8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* PLL is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8000cec:	6843      	ldr	r3, [r0, #4]
    {
      /* Check the PLL ready flag */
      if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == RESET)
 8000cee:	4a2b      	ldr	r2, [pc, #172]	; (8000d9c <HAL_RCC_ClockConfig+0x160>)
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* PLL is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8000cf0:	2b03      	cmp	r3, #3
    {
      /* Check the PLL ready flag */
      if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == RESET)
 8000cf2:	6812      	ldr	r2, [r2, #0]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* PLL is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8000cf4:	d049      	beq.n	8000d8a <HAL_RCC_ClockConfig+0x14e>
#endif
    }
    else
    {
      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8000cf6:	2b02      	cmp	r3, #2
 8000cf8:	d041      	beq.n	8000d7e <HAL_RCC_ClockConfig+0x142>
        {
          return HAL_ERROR;
        }
      }
      /* MSI is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 8000cfa:	2b00      	cmp	r3, #0
 8000cfc:	d148      	bne.n	8000d90 <HAL_RCC_ClockConfig+0x154>
      {
        /* Check the MSI ready flag */
        if(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == RESET)
 8000cfe:	0796      	lsls	r6, r2, #30
 8000d00:	d5ae      	bpl.n	8000c60 <HAL_RCC_ClockConfig+0x24>
      }
#endif

    }

    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8000d02:	4e26      	ldr	r6, [pc, #152]	; (8000d9c <HAL_RCC_ClockConfig+0x160>)
 8000d04:	68b2      	ldr	r2, [r6, #8]
 8000d06:	f022 0203 	bic.w	r2, r2, #3
 8000d0a:	4313      	orrs	r3, r2
 8000d0c:	60b3      	str	r3, [r6, #8]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8000d0e:	f7ff fa87 	bl	8000220 <HAL_GetTick>

    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8000d12:	686b      	ldr	r3, [r5, #4]
 8000d14:	2b03      	cmp	r3, #3
    }

    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8000d16:	4607      	mov	r7, r0

    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
      {
        if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000d18:	f241 3888 	movw	r8, #5000	; 0x1388
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8000d1c:	d013      	beq.n	8000d46 <HAL_RCC_ClockConfig+0x10a>
        }
      }
    }
    else
    {
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8000d1e:	2b02      	cmp	r3, #2
 8000d20:	d027      	beq.n	8000d72 <HAL_RCC_ClockConfig+0x136>
          {
            return HAL_TIMEOUT;
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 8000d22:	b9db      	cbnz	r3, 8000d5c <HAL_RCC_ClockConfig+0x120>
 8000d24:	e004      	b.n	8000d30 <HAL_RCC_ClockConfig+0xf4>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_MSI)
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000d26:	f7ff fa7b 	bl	8000220 <HAL_GetTick>
 8000d2a:	1bc0      	subs	r0, r0, r7
 8000d2c:	4540      	cmp	r0, r8
 8000d2e:	d829      	bhi.n	8000d84 <HAL_RCC_ClockConfig+0x148>
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_MSI)
 8000d30:	68b3      	ldr	r3, [r6, #8]
 8000d32:	f013 0f0c 	tst.w	r3, #12
 8000d36:	d1f6      	bne.n	8000d26 <HAL_RCC_ClockConfig+0xea>
 8000d38:	682b      	ldr	r3, [r5, #0]
 8000d3a:	e799      	b.n	8000c70 <HAL_RCC_ClockConfig+0x34>

    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
      {
        if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000d3c:	f7ff fa70 	bl	8000220 <HAL_GetTick>
 8000d40:	1bc0      	subs	r0, r0, r7
 8000d42:	4540      	cmp	r0, r8
 8000d44:	d81e      	bhi.n	8000d84 <HAL_RCC_ClockConfig+0x148>
    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8000d46:	68b3      	ldr	r3, [r6, #8]
 8000d48:	f003 030c 	and.w	r3, r3, #12
 8000d4c:	2b0c      	cmp	r3, #12
 8000d4e:	d1f5      	bne.n	8000d3c <HAL_RCC_ClockConfig+0x100>
 8000d50:	e7f2      	b.n	8000d38 <HAL_RCC_ClockConfig+0xfc>
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000d52:	f7ff fa65 	bl	8000220 <HAL_GetTick>
 8000d56:	1bc0      	subs	r0, r0, r7
 8000d58:	4540      	cmp	r0, r8
 8000d5a:	d813      	bhi.n	8000d84 <HAL_RCC_ClockConfig+0x148>
          }
        }
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
 8000d5c:	68b3      	ldr	r3, [r6, #8]
 8000d5e:	f003 030c 	and.w	r3, r3, #12
 8000d62:	2b04      	cmp	r3, #4
 8000d64:	d1f5      	bne.n	8000d52 <HAL_RCC_ClockConfig+0x116>
 8000d66:	e7e7      	b.n	8000d38 <HAL_RCC_ClockConfig+0xfc>
    {
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000d68:	f7ff fa5a 	bl	8000220 <HAL_GetTick>
 8000d6c:	1bc0      	subs	r0, r0, r7
 8000d6e:	4540      	cmp	r0, r8
 8000d70:	d808      	bhi.n	8000d84 <HAL_RCC_ClockConfig+0x148>
    }
    else
    {
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
 8000d72:	68b3      	ldr	r3, [r6, #8]
 8000d74:	f003 030c 	and.w	r3, r3, #12
 8000d78:	2b08      	cmp	r3, #8
 8000d7a:	d1f5      	bne.n	8000d68 <HAL_RCC_ClockConfig+0x12c>
 8000d7c:	e7dc      	b.n	8000d38 <HAL_RCC_ClockConfig+0xfc>
    {
      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        /* Check the HSE ready flag */
        if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == RESET)
 8000d7e:	0397      	lsls	r7, r2, #14
 8000d80:	d4bf      	bmi.n	8000d02 <HAL_RCC_ClockConfig+0xc6>
 8000d82:	e76d      	b.n	8000c60 <HAL_RCC_ClockConfig+0x24>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
      {
        if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
        {
          return HAL_TIMEOUT;
 8000d84:	2003      	movs	r0, #3
 8000d86:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

    /* PLL is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
    {
      /* Check the PLL ready flag */
      if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == RESET)
 8000d8a:	0192      	lsls	r2, r2, #6
 8000d8c:	d4b9      	bmi.n	8000d02 <HAL_RCC_ClockConfig+0xc6>
 8000d8e:	e767      	b.n	8000c60 <HAL_RCC_ClockConfig+0x24>
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */
        if(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == RESET)
 8000d90:	0550      	lsls	r0, r2, #21
 8000d92:	f57f af65 	bpl.w	8000c60 <HAL_RCC_ClockConfig+0x24>
 8000d96:	e7b4      	b.n	8000d02 <HAL_RCC_ClockConfig+0xc6>
 8000d98:	40022000 	.word	0x40022000
 8000d9c:	40021000 	.word	0x40021000
 8000da0:	08001ae0 	.word	0x08001ae0
 8000da4:	20000000 	.word	0x20000000

08000da8 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency.
  * @retval HCLK frequency in Hz
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
 8000da8:	4b01      	ldr	r3, [pc, #4]	; (8000db0 <HAL_RCC_GetHCLKFreq+0x8>)
}
 8000daa:	6818      	ldr	r0, [r3, #0]
 8000dac:	4770      	bx	lr
 8000dae:	bf00      	nop
 8000db0:	20000000 	.word	0x20000000

08000db4 <TIM_OC1_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */
static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8000db4:	b4f0      	push	{r4, r5, r6, r7}
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0;

   /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8000db6:	6a04      	ldr	r4, [r0, #32]
  tmpccmrx |= OC_Config->OCMode;

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 8000db8:	688f      	ldr	r7, [r1, #8]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
  tmpccmrx &= ~TIM_CCMR1_CC1S;
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8000dba:	680e      	ldr	r6, [r1, #0]
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;

  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 8000dbc:	4d17      	ldr	r5, [pc, #92]	; (8000e1c <TIM_OC1_SetConfig+0x68>)
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0;

   /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8000dbe:	f024 0401 	bic.w	r4, r4, #1
 8000dc2:	6204      	str	r4, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8000dc4:	6a02      	ldr	r2, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8000dc6:	6844      	ldr	r4, [r0, #4]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8000dc8:	6983      	ldr	r3, [r0, #24]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 8000dca:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
 8000dce:	f022 0202 	bic.w	r2, r2, #2
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 8000dd2:	f023 0373 	bic.w	r3, r3, #115	; 0x73
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;

  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 8000dd6:	42a8      	cmp	r0, r5
  tmpccmrx |= OC_Config->OCMode;

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 8000dd8:	ea42 0207 	orr.w	r2, r2, r7

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
  tmpccmrx &= ~TIM_CCMR1_CC1S;
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8000ddc:	ea43 0306 	orr.w	r3, r3, r6
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;

  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 8000de0:	d00e      	beq.n	8000e00 <TIM_OC1_SetConfig+0x4c>
 8000de2:	f505 55a0 	add.w	r5, r5, #5120	; 0x1400
 8000de6:	42a8      	cmp	r0, r5
 8000de8:	d00a      	beq.n	8000e00 <TIM_OC1_SetConfig+0x4c>
 8000dea:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000dee:	42a8      	cmp	r0, r5
 8000df0:	d006      	beq.n	8000e00 <TIM_OC1_SetConfig+0x4c>

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 8000df2:	6849      	ldr	r1, [r1, #4]
    tmpcr2 |= OC_Config->OCIdleState;
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8000df4:	6044      	str	r4, [r0, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 8000df6:	6183      	str	r3, [r0, #24]
  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
}
 8000df8:	bcf0      	pop	{r4, r5, r6, r7}

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 8000dfa:	6341      	str	r1, [r0, #52]	; 0x34

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8000dfc:	6202      	str	r2, [r0, #32]
}
 8000dfe:	4770      	bx	lr
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
 8000e00:	68cd      	ldr	r5, [r1, #12]
    tmpcr2 &= ~TIM_CR2_OIS1;
    tmpcr2 &= ~TIM_CR2_OIS1N;
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 8000e02:	694e      	ldr	r6, [r1, #20]
  {
    /* Check parameters */
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
 8000e04:	f022 0208 	bic.w	r2, r2, #8
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
 8000e08:	432a      	orrs	r2, r5
    tmpcr2 &= ~TIM_CR2_OIS1;
    tmpcr2 &= ~TIM_CR2_OIS1N;
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 8000e0a:	698d      	ldr	r5, [r1, #24]
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS1;
    tmpcr2 &= ~TIM_CR2_OIS1N;
 8000e0c:	f424 7440 	bic.w	r4, r4, #768	; 0x300
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 8000e10:	4335      	orrs	r5, r6
    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
 8000e12:	f022 0204 	bic.w	r2, r2, #4
    tmpcr2 &= ~TIM_CR2_OIS1;
    tmpcr2 &= ~TIM_CR2_OIS1N;
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 8000e16:	432c      	orrs	r4, r5
 8000e18:	e7eb      	b.n	8000df2 <TIM_OC1_SetConfig+0x3e>
 8000e1a:	bf00      	nop
 8000e1c:	40012c00 	.word	0x40012c00

08000e20 <TIM_OC3_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */
static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8000e20:	b4f0      	push	{r4, r5, r6, r7}
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0;

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8000e22:	6a04      	ldr	r4, [r0, #32]
  tmpccmrx |= OC_Config->OCMode;

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8);
 8000e24:	688f      	ldr	r7, [r1, #8]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
  tmpccmrx &= ~TIM_CCMR2_CC3S;
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8000e26:	680e      	ldr	r6, [r1, #0]
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8);

  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 8000e28:	4d17      	ldr	r5, [pc, #92]	; (8000e88 <TIM_OC3_SetConfig+0x68>)
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0;

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8000e2a:	f424 7480 	bic.w	r4, r4, #256	; 0x100
 8000e2e:	6204      	str	r4, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8000e30:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8000e32:	6844      	ldr	r4, [r0, #4]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8000e34:	69c2      	ldr	r2, [r0, #28]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 8000e36:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
 8000e3a:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 8000e3e:	f022 0273 	bic.w	r2, r2, #115	; 0x73
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8);

  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 8000e42:	42a8      	cmp	r0, r5
  tmpccmrx |= OC_Config->OCMode;

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8);
 8000e44:	ea43 2307 	orr.w	r3, r3, r7, lsl #8

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
  tmpccmrx &= ~TIM_CCMR2_CC3S;
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8000e48:	ea42 0206 	orr.w	r2, r2, r6
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8);

  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 8000e4c:	d00c      	beq.n	8000e68 <TIM_OC3_SetConfig+0x48>
    tmpccer |= (OC_Config->OCNPolarity << 8);
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
  }

  if(IS_TIM_BREAK_INSTANCE(TIMx))
 8000e4e:	4d0f      	ldr	r5, [pc, #60]	; (8000e8c <TIM_OC3_SetConfig+0x6c>)
 8000e50:	42a8      	cmp	r0, r5
 8000e52:	d010      	beq.n	8000e76 <TIM_OC3_SetConfig+0x56>
 8000e54:	4d0e      	ldr	r5, [pc, #56]	; (8000e90 <TIM_OC3_SetConfig+0x70>)
 8000e56:	42a8      	cmp	r0, r5
 8000e58:	d00d      	beq.n	8000e76 <TIM_OC3_SetConfig+0x56>

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 8000e5a:	6849      	ldr	r1, [r1, #4]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4);
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8000e5c:	6044      	str	r4, [r0, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 8000e5e:	61c2      	str	r2, [r0, #28]
  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
}
 8000e60:	bcf0      	pop	{r4, r5, r6, r7}

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 8000e62:	63c1      	str	r1, [r0, #60]	; 0x3c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8000e64:	6203      	str	r3, [r0, #32]
}
 8000e66:	4770      	bx	lr
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC3NP;
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 8);
 8000e68:	68cd      	ldr	r5, [r1, #12]
  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC3NP;
 8000e6a:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 8);
 8000e6e:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
 8000e72:	f423 6380 	bic.w	r3, r3, #1024	; 0x400

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
    tmpcr2 &= ~TIM_CR2_OIS3N;
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4);
 8000e76:	694e      	ldr	r6, [r1, #20]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4);
 8000e78:	698d      	ldr	r5, [r1, #24]
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
    tmpcr2 &= ~TIM_CR2_OIS3N;
 8000e7a:	f424 5440 	bic.w	r4, r4, #12288	; 0x3000
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4);
 8000e7e:	ea44 1406 	orr.w	r4, r4, r6, lsl #4
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4);
 8000e82:	ea44 1405 	orr.w	r4, r4, r5, lsl #4
 8000e86:	e7e8      	b.n	8000e5a <TIM_OC3_SetConfig+0x3a>
 8000e88:	40012c00 	.word	0x40012c00
 8000e8c:	40014000 	.word	0x40014000
 8000e90:	40014400 	.word	0x40014400

08000e94 <TIM_OC4_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */
static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8000e94:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8000e96:	6a04      	ldr	r4, [r0, #32]
  tmpccmrx |= (OC_Config->OCMode << 8);

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12);
 8000e98:	f8d1 e008 	ldr.w	lr, [r1, #8]
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
  tmpccmrx &= ~TIM_CCMR2_CC4S;

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);
 8000e9c:	680f      	ldr	r7, [r1, #0]
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12);

  if(IS_TIM_BREAK_INSTANCE(TIMx))
 8000e9e:	4e13      	ldr	r6, [pc, #76]	; (8000eec <TIM_OC4_SetConfig+0x58>)
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8000ea0:	f424 5480 	bic.w	r4, r4, #4096	; 0x1000
 8000ea4:	6204      	str	r4, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8000ea6:	6a04      	ldr	r4, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8000ea8:	6845      	ldr	r5, [r0, #4]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8000eaa:	69c2      	ldr	r2, [r0, #28]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 8000eac:	f022 7380 	bic.w	r3, r2, #16777216	; 0x1000000
 8000eb0:	f423 43e6 	bic.w	r3, r3, #29440	; 0x7300

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
 8000eb4:	f424 5200 	bic.w	r2, r4, #8192	; 0x2000
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12);

  if(IS_TIM_BREAK_INSTANCE(TIMx))
 8000eb8:	42b0      	cmp	r0, r6
  tmpccmrx |= (OC_Config->OCMode << 8);

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12);
 8000eba:	ea42 320e 	orr.w	r2, r2, lr, lsl #12
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
  tmpccmrx &= ~TIM_CCMR2_CC4S;

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);
 8000ebe:	ea43 2307 	orr.w	r3, r3, r7, lsl #8
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12);

  if(IS_TIM_BREAK_INSTANCE(TIMx))
 8000ec2:	d00c      	beq.n	8000ede <TIM_OC4_SetConfig+0x4a>
 8000ec4:	4c0a      	ldr	r4, [pc, #40]	; (8000ef0 <TIM_OC4_SetConfig+0x5c>)
 8000ec6:	42a0      	cmp	r0, r4
 8000ec8:	d009      	beq.n	8000ede <TIM_OC4_SetConfig+0x4a>
 8000eca:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 8000ece:	42a0      	cmp	r0, r4
 8000ed0:	d005      	beq.n	8000ede <TIM_OC4_SetConfig+0x4a>

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 8000ed2:	6849      	ldr	r1, [r1, #4]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6);
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8000ed4:	6045      	str	r5, [r0, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 8000ed6:	61c3      	str	r3, [r0, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 8000ed8:	6401      	str	r1, [r0, #64]	; 0x40

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8000eda:	6202      	str	r2, [r0, #32]
 8000edc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

   /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS4;
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6);
 8000ede:	694c      	ldr	r4, [r1, #20]
  if(IS_TIM_BREAK_INSTANCE(TIMx))
  {
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

   /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS4;
 8000ee0:	f425 4580 	bic.w	r5, r5, #16384	; 0x4000
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6);
 8000ee4:	ea45 1584 	orr.w	r5, r5, r4, lsl #6
 8000ee8:	e7f3      	b.n	8000ed2 <TIM_OC4_SetConfig+0x3e>
 8000eea:	bf00      	nop
 8000eec:	40012c00 	.word	0x40012c00
 8000ef0:	40014000 	.word	0x40014000

08000ef4 <TIM_OC5_SetConfig>:
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0;

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC5E;
 8000ef4:	6a02      	ldr	r2, [r0, #32]
 8000ef6:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */
static void TIM_OC5_SetConfig(TIM_TypeDef *TIMx,
                              TIM_OC_InitTypeDef *OC_Config)
{
 8000efa:	b4f0      	push	{r4, r5, r6, r7}
  tmpccmrx |= OC_Config->OCMode;

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC5P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 16);
 8000efc:	688f      	ldr	r7, [r1, #8]
  tmpccmrx = TIMx->CCMR3;

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8000efe:	680c      	ldr	r4, [r1, #0]
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0;

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC5E;
 8000f00:	6202      	str	r2, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8000f02:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8000f04:	6845      	ldr	r5, [r0, #4]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
 8000f06:	6d42      	ldr	r2, [r0, #84]	; 0x54
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC5P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 16);

  if(IS_TIM_BREAK_INSTANCE(TIMx))
 8000f08:	4e10      	ldr	r6, [pc, #64]	; (8000f4c <TIM_OC5_SetConfig+0x58>)
  tmpcr2 =  TIMx->CR2;
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
 8000f0a:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC5P;
 8000f0e:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
  tmpcr2 =  TIMx->CR2;
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
 8000f12:	f022 0270 	bic.w	r2, r2, #112	; 0x70
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC5P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 16);

  if(IS_TIM_BREAK_INSTANCE(TIMx))
 8000f16:	42b0      	cmp	r0, r6
  tmpccmrx |= OC_Config->OCMode;

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC5P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 16);
 8000f18:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
  tmpccmrx = TIMx->CCMR3;

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8000f1c:	ea42 0204 	orr.w	r2, r2, r4
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC5P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 16);

  if(IS_TIM_BREAK_INSTANCE(TIMx))
 8000f20:	d00d      	beq.n	8000f3e <TIM_OC5_SetConfig+0x4a>
 8000f22:	4c0b      	ldr	r4, [pc, #44]	; (8000f50 <TIM_OC5_SetConfig+0x5c>)
 8000f24:	42a0      	cmp	r0, r4
 8000f26:	d00a      	beq.n	8000f3e <TIM_OC5_SetConfig+0x4a>
 8000f28:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 8000f2c:	42a0      	cmp	r0, r4
 8000f2e:	d006      	beq.n	8000f3e <TIM_OC5_SetConfig+0x4a>

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR5 = OC_Config->Pulse;
 8000f30:	6849      	ldr	r1, [r1, #4]
    tmpcr2 &= ~TIM_CR2_OIS5;
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 8);
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8000f32:	6045      	str	r5, [r0, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 8000f34:	6542      	str	r2, [r0, #84]	; 0x54
  /* Set the Capture Compare Register value */
  TIMx->CCR5 = OC_Config->Pulse;

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
}
 8000f36:	bcf0      	pop	{r4, r5, r6, r7}

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR5 = OC_Config->Pulse;
 8000f38:	6581      	str	r1, [r0, #88]	; 0x58

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8000f3a:	6203      	str	r3, [r0, #32]
}
 8000f3c:	4770      	bx	lr
  if(IS_TIM_BREAK_INSTANCE(TIMx))
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS5;
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 8);
 8000f3e:	694c      	ldr	r4, [r1, #20]
  tmpccer |= (OC_Config->OCPolarity << 16);

  if(IS_TIM_BREAK_INSTANCE(TIMx))
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS5;
 8000f40:	f425 3580 	bic.w	r5, r5, #65536	; 0x10000
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 8);
 8000f44:	ea45 2504 	orr.w	r5, r5, r4, lsl #8
 8000f48:	e7f2      	b.n	8000f30 <TIM_OC5_SetConfig+0x3c>
 8000f4a:	bf00      	nop
 8000f4c:	40012c00 	.word	0x40012c00
 8000f50:	40014000 	.word	0x40014000

08000f54 <TIM_OC6_SetConfig>:
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */
static void TIM_OC6_SetConfig(TIM_TypeDef *TIMx,
                              TIM_OC_InitTypeDef *OC_Config)
{
 8000f54:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0;

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC6E;
 8000f56:	6a04      	ldr	r4, [r0, #32]
  tmpccmrx |= (OC_Config->OCMode << 8);

  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 20);
 8000f58:	f8d1 e008 	ldr.w	lr, [r1, #8]
  tmpccmrx = TIMx->CCMR3;

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);
 8000f5c:	680f      	ldr	r7, [r1, #0]
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 20);

  if(IS_TIM_BREAK_INSTANCE(TIMx))
 8000f5e:	4e13      	ldr	r6, [pc, #76]	; (8000fac <TIM_OC6_SetConfig+0x58>)
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0;

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC6E;
 8000f60:	f424 1480 	bic.w	r4, r4, #1048576	; 0x100000
 8000f64:	6204      	str	r4, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8000f66:	6a04      	ldr	r4, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8000f68:	6845      	ldr	r5, [r0, #4]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
 8000f6a:	6d42      	ldr	r2, [r0, #84]	; 0x54

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
 8000f6c:	f022 7380 	bic.w	r3, r2, #16777216	; 0x1000000
 8000f70:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);

  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
 8000f74:	f424 1200 	bic.w	r2, r4, #2097152	; 0x200000
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 20);

  if(IS_TIM_BREAK_INSTANCE(TIMx))
 8000f78:	42b0      	cmp	r0, r6
  tmpccmrx |= (OC_Config->OCMode << 8);

  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 20);
 8000f7a:	ea42 520e 	orr.w	r2, r2, lr, lsl #20
  tmpccmrx = TIMx->CCMR3;

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);
 8000f7e:	ea43 2307 	orr.w	r3, r3, r7, lsl #8
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 20);

  if(IS_TIM_BREAK_INSTANCE(TIMx))
 8000f82:	d00c      	beq.n	8000f9e <TIM_OC6_SetConfig+0x4a>
 8000f84:	4c0a      	ldr	r4, [pc, #40]	; (8000fb0 <TIM_OC6_SetConfig+0x5c>)
 8000f86:	42a0      	cmp	r0, r4
 8000f88:	d009      	beq.n	8000f9e <TIM_OC6_SetConfig+0x4a>
 8000f8a:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 8000f8e:	42a0      	cmp	r0, r4
 8000f90:	d005      	beq.n	8000f9e <TIM_OC6_SetConfig+0x4a>

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR6 = OC_Config->Pulse;
 8000f92:	6849      	ldr	r1, [r1, #4]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 10);
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8000f94:	6045      	str	r5, [r0, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 8000f96:	6543      	str	r3, [r0, #84]	; 0x54

  /* Set the Capture Compare Register value */
  TIMx->CCR6 = OC_Config->Pulse;
 8000f98:	65c1      	str	r1, [r0, #92]	; 0x5c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8000f9a:	6202      	str	r2, [r0, #32]
 8000f9c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if(IS_TIM_BREAK_INSTANCE(TIMx))
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS6;
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 10);
 8000f9e:	694c      	ldr	r4, [r1, #20]
  tmpccer |= (OC_Config->OCPolarity << 20);

  if(IS_TIM_BREAK_INSTANCE(TIMx))
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS6;
 8000fa0:	f425 2580 	bic.w	r5, r5, #262144	; 0x40000
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 10);
 8000fa4:	ea45 2584 	orr.w	r5, r5, r4, lsl #10
 8000fa8:	e7f3      	b.n	8000f92 <TIM_OC6_SetConfig+0x3e>
 8000faa:	bf00      	nop
 8000fac:	40012c00 	.word	0x40012c00
 8000fb0:	40014000 	.word	0x40014000

08000fb4 <HAL_TIM_Base_Start>:

  /* Set the TIM state */
  htim->State= HAL_TIM_STATE_BUSY;

  /* Enable the Peripheral */
  __HAL_TIM_ENABLE(htim);
 8000fb4:	6801      	ldr	r1, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Set the TIM state */
  htim->State= HAL_TIM_STATE_BUSY;
 8000fb6:	2202      	movs	r2, #2
  * @brief  Starts the TIM Base generation.
  * @param  htim TIM handle
  * @retval HAL status
*/
HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
{
 8000fb8:	b410      	push	{r4}
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Set the TIM state */
  htim->State= HAL_TIM_STATE_BUSY;
 8000fba:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d

  /* Enable the Peripheral */
  __HAL_TIM_ENABLE(htim);
 8000fbe:	680a      	ldr	r2, [r1, #0]

  /* Change the TIM state*/
  htim->State= HAL_TIM_STATE_READY;
 8000fc0:	2401      	movs	r4, #1
  * @brief  Starts the TIM Base generation.
  * @param  htim TIM handle
  * @retval HAL status
*/
HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
{
 8000fc2:	4603      	mov	r3, r0

  /* Set the TIM state */
  htim->State= HAL_TIM_STATE_BUSY;

  /* Enable the Peripheral */
  __HAL_TIM_ENABLE(htim);
 8000fc4:	4322      	orrs	r2, r4
 8000fc6:	600a      	str	r2, [r1, #0]
  /* Change the TIM state*/
  htim->State= HAL_TIM_STATE_READY;

  /* Return function status */
  return HAL_OK;
}
 8000fc8:	2000      	movs	r0, #0

  /* Enable the Peripheral */
  __HAL_TIM_ENABLE(htim);

  /* Change the TIM state*/
  htim->State= HAL_TIM_STATE_READY;
 8000fca:	f883 403d 	strb.w	r4, [r3, #61]	; 0x3d

  /* Return function status */
  return HAL_OK;
}
 8000fce:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000fd2:	4770      	bx	lr

08000fd4 <HAL_TIM_PWM_MspInit>:
 8000fd4:	4770      	bx	lr
 8000fd6:	bf00      	nop

08000fd8 <HAL_TIM_PWM_Start>:
{
  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  /* Enable the Capture compare channel */
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 8000fd8:	6803      	ldr	r3, [r0, #0]

  /* Check the parameters */
  assert_param(IS_TIM_CC1_INSTANCE(TIMx));
  assert_param(IS_TIM_CHANNELS(Channel));

  tmp = TIM_CCER_CC1E << Channel;
 8000fda:	2201      	movs	r2, #1

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;
 8000fdc:	6a18      	ldr	r0, [r3, #32]

  /* Check the parameters */
  assert_param(IS_TIM_CC1_INSTANCE(TIMx));
  assert_param(IS_TIM_CHANNELS(Channel));

  tmp = TIM_CCER_CC1E << Channel;
 8000fde:	fa02 f101 	lsl.w	r1, r2, r1

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;
 8000fe2:	ea20 0001 	bic.w	r0, r0, r1
  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
  * @retval HAL status
*/
HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
{
 8000fe6:	b410      	push	{r4}
  assert_param(IS_TIM_CHANNELS(Channel));

  tmp = TIM_CCER_CC1E << Channel;

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;
 8000fe8:	6218      	str	r0, [r3, #32]

  /* Set or reset the CCxE Bit */
  TIMx->CCER |=  (uint32_t)(ChannelState << Channel);
 8000fea:	6a1a      	ldr	r2, [r3, #32]
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  /* Enable the Capture compare channel */
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);

  if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 8000fec:	4c0c      	ldr	r4, [pc, #48]	; (8001020 <HAL_TIM_PWM_Start+0x48>)

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;

  /* Set or reset the CCxE Bit */
  TIMx->CCER |=  (uint32_t)(ChannelState << Channel);
 8000fee:	4311      	orrs	r1, r2
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  /* Enable the Capture compare channel */
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);

  if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 8000ff0:	42a3      	cmp	r3, r4

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;

  /* Set or reset the CCxE Bit */
  TIMx->CCER |=  (uint32_t)(ChannelState << Channel);
 8000ff2:	6219      	str	r1, [r3, #32]
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  /* Enable the Capture compare channel */
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);

  if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 8000ff4:	d00e      	beq.n	8001014 <HAL_TIM_PWM_Start+0x3c>
 8000ff6:	4a0b      	ldr	r2, [pc, #44]	; (8001024 <HAL_TIM_PWM_Start+0x4c>)
 8000ff8:	4293      	cmp	r3, r2
 8000ffa:	d00b      	beq.n	8001014 <HAL_TIM_PWM_Start+0x3c>
 8000ffc:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001000:	4293      	cmp	r3, r2
 8001002:	d007      	beq.n	8001014 <HAL_TIM_PWM_Start+0x3c>
    /* Enable the main output */
    __HAL_TIM_MOE_ENABLE(htim);
  }

  /* Enable the Peripheral */
  __HAL_TIM_ENABLE(htim);
 8001004:	681a      	ldr	r2, [r3, #0]

  /* Return function status */
  return HAL_OK;
}
 8001006:	f85d 4b04 	ldr.w	r4, [sp], #4
    /* Enable the main output */
    __HAL_TIM_MOE_ENABLE(htim);
  }

  /* Enable the Peripheral */
  __HAL_TIM_ENABLE(htim);
 800100a:	f042 0201 	orr.w	r2, r2, #1

  /* Return function status */
  return HAL_OK;
}
 800100e:	2000      	movs	r0, #0
    /* Enable the main output */
    __HAL_TIM_MOE_ENABLE(htim);
  }

  /* Enable the Peripheral */
  __HAL_TIM_ENABLE(htim);
 8001010:	601a      	str	r2, [r3, #0]

  /* Return function status */
  return HAL_OK;
}
 8001012:	4770      	bx	lr
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);

  if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
  {
    /* Enable the main output */
    __HAL_TIM_MOE_ENABLE(htim);
 8001014:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8001016:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800101a:	645a      	str	r2, [r3, #68]	; 0x44
 800101c:	e7f2      	b.n	8001004 <HAL_TIM_PWM_Start+0x2c>
 800101e:	bf00      	nop
 8001020:	40012c00 	.word	0x40012c00
 8001024:	40014000 	.word	0x40014000

08001028 <HAL_TIM_ConfigClockSource>:
HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig)
{
  uint32_t tmpsmcr = 0;

  /* Process Locked */
  __HAL_LOCK(htim);
 8001028:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 800102c:	2b01      	cmp	r3, #1
 800102e:	d040      	beq.n	80010b2 <HAL_TIM_ConfigClockSource+0x8a>

  htim->State = HAL_TIM_STATE_BUSY;
 8001030:	2202      	movs	r2, #2

  /* Check the parameters */
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));

  /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
  tmpsmcr = htim->Instance->SMCR;
 8001032:	6803      	ldr	r3, [r0, #0]
  * @param  sClockSourceConfig pointer to a TIM_ClockConfigTypeDef structure that
  *         contains the clock source information for the TIM peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig)
{
 8001034:	b470      	push	{r4, r5, r6}
  uint32_t tmpsmcr = 0;

  /* Process Locked */
  __HAL_LOCK(htim);

  htim->State = HAL_TIM_STATE_BUSY;
 8001036:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d

  /* Check the parameters */
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));

  /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
  tmpsmcr = htim->Instance->SMCR;
 800103a:	689d      	ldr	r5, [r3, #8]
  tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
  htim->Instance->SMCR = tmpsmcr;

  switch (sClockSourceConfig->ClockSource)
 800103c:	680c      	ldr	r4, [r1, #0]
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));

  /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
  tmpsmcr = htim->Instance->SMCR;
  tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 800103e:	4a5d      	ldr	r2, [pc, #372]	; (80011b4 <HAL_TIM_ConfigClockSource+0x18c>)
  htim->Instance->SMCR = tmpsmcr;

  switch (sClockSourceConfig->ClockSource)
 8001040:	2c40      	cmp	r4, #64	; 0x40
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));

  /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
  tmpsmcr = htim->Instance->SMCR;
  tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8001042:	ea02 0205 	and.w	r2, r2, r5
HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig)
{
  uint32_t tmpsmcr = 0;

  /* Process Locked */
  __HAL_LOCK(htim);
 8001046:	f04f 0501 	mov.w	r5, #1
 800104a:	f880 503c 	strb.w	r5, [r0, #60]	; 0x3c

  /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
  tmpsmcr = htim->Instance->SMCR;
  tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
  htim->Instance->SMCR = tmpsmcr;
 800104e:	609a      	str	r2, [r3, #8]

  switch (sClockSourceConfig->ClockSource)
 8001050:	d079      	beq.n	8001146 <HAL_TIM_ConfigClockSource+0x11e>
 8001052:	d918      	bls.n	8001086 <HAL_TIM_ConfigClockSource+0x5e>
 8001054:	2c70      	cmp	r4, #112	; 0x70
 8001056:	d062      	beq.n	800111e <HAL_TIM_ConfigClockSource+0xf6>
 8001058:	d92d      	bls.n	80010b6 <HAL_TIM_ConfigClockSource+0x8e>
 800105a:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
 800105e:	d057      	beq.n	8001110 <HAL_TIM_ConfigClockSource+0xe8>
 8001060:	f5b4 5f00 	cmp.w	r4, #8192	; 0x2000
 8001064:	d11c      	bne.n	80010a0 <HAL_TIM_ConfigClockSource+0x78>
void TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler,
                       uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
{
  uint32_t tmpsmcr = 0;

  tmpsmcr = TIMx->SMCR;
 8001066:	689c      	ldr	r4, [r3, #8]
 8001068:	688a      	ldr	r2, [r1, #8]
 800106a:	684d      	ldr	r5, [r1, #4]

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8)));
 800106c:	68ce      	ldr	r6, [r1, #12]
 800106e:	432a      	orrs	r2, r5
 8001070:	f424 417f 	bic.w	r1, r4, #65280	; 0xff00
 8001074:	430a      	orrs	r2, r1
 8001076:	ea42 2206 	orr.w	r2, r2, r6, lsl #8

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800107a:	609a      	str	r2, [r3, #8]
      TIM_ETR_SetConfig(htim->Instance,
                        sClockSourceConfig->ClockPrescaler,
                        sClockSourceConfig->ClockPolarity,
                        sClockSourceConfig->ClockFilter);
      /* Enable the External clock mode2 */
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 800107c:	689a      	ldr	r2, [r3, #8]
 800107e:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8001082:	609a      	str	r2, [r3, #8]
    }
    break;
 8001084:	e00c      	b.n	80010a0 <HAL_TIM_ConfigClockSource+0x78>
  tmpsmcr = htim->Instance->SMCR;
  tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
  htim->Instance->SMCR = tmpsmcr;

  switch (sClockSourceConfig->ClockSource)
 8001086:	2c10      	cmp	r4, #16
 8001088:	d032      	beq.n	80010f0 <HAL_TIM_ConfigClockSource+0xc8>
 800108a:	d938      	bls.n	80010fe <HAL_TIM_ConfigClockSource+0xd6>
 800108c:	2c20      	cmp	r4, #32
 800108e:	d072      	beq.n	8001176 <HAL_TIM_ConfigClockSource+0x14e>
 8001090:	2c30      	cmp	r4, #48	; 0x30
 8001092:	d105      	bne.n	80010a0 <HAL_TIM_ConfigClockSource+0x78>
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint16_t InputTriggerSource)
{
  uint32_t tmpsmcr = 0;

   /* Get the TIMx SMCR register value */
   tmpsmcr = TIMx->SMCR;
 8001094:	689a      	ldr	r2, [r3, #8]
   /* Reset the TS Bits */
   tmpsmcr &= ~TIM_SMCR_TS;
 8001096:	f022 0270 	bic.w	r2, r2, #112	; 0x70
   /* Set the Input Trigger source and the slave mode*/
   tmpsmcr |= InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1;
 800109a:	f042 0237 	orr.w	r2, r2, #55	; 0x37
   /* Write to TIMx SMCR */
   TIMx->SMCR = tmpsmcr;
 800109e:	609a      	str	r2, [r3, #8]
  default:
    break;
  }
  htim->State = HAL_TIM_STATE_READY;

  __HAL_UNLOCK(htim);
 80010a0:	2300      	movs	r3, #0
    break;

  default:
    break;
  }
  htim->State = HAL_TIM_STATE_READY;
 80010a2:	2201      	movs	r2, #1
 80010a4:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d

  __HAL_UNLOCK(htim);
 80010a8:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c

  return HAL_OK;
}
 80010ac:	bc70      	pop	{r4, r5, r6}
  }
  htim->State = HAL_TIM_STATE_READY;

  __HAL_UNLOCK(htim);

  return HAL_OK;
 80010ae:	4618      	mov	r0, r3
}
 80010b0:	4770      	bx	lr
HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig)
{
  uint32_t tmpsmcr = 0;

  /* Process Locked */
  __HAL_LOCK(htim);
 80010b2:	2002      	movs	r0, #2
 80010b4:	4770      	bx	lr
  tmpsmcr = htim->Instance->SMCR;
  tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
  htim->Instance->SMCR = tmpsmcr;

  switch (sClockSourceConfig->ClockSource)
 80010b6:	2c50      	cmp	r4, #80	; 0x50
 80010b8:	d064      	beq.n	8001184 <HAL_TIM_ConfigClockSource+0x15c>
 80010ba:	2c60      	cmp	r4, #96	; 0x60
 80010bc:	d1f0      	bne.n	80010a0 <HAL_TIM_ConfigClockSource+0x78>
{
  uint32_t tmpccmr1 = 0;
  uint32_t tmpccer = 0;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 80010be:	6a1c      	ldr	r4, [r3, #32]

      /* Check TI2 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI2_ConfigInputStage(htim->Instance,
 80010c0:	684d      	ldr	r5, [r1, #4]
 80010c2:	68ce      	ldr	r6, [r1, #12]
{
  uint32_t tmpccmr1 = 0;
  uint32_t tmpccer = 0;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 80010c4:	f024 0410 	bic.w	r4, r4, #16
 80010c8:	621c      	str	r4, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 80010ca:	6999      	ldr	r1, [r3, #24]
  tmpccer = TIMx->CCER;
 80010cc:	6a1a      	ldr	r2, [r3, #32]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 80010ce:	f421 4170 	bic.w	r1, r1, #61440	; 0xf000
  tmpccmr1 |= (TIM_ICFilter << 12);

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 80010d2:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
  tmpccer |= (TIM_ICPolarity << 4);
 80010d6:	ea42 1205 	orr.w	r2, r2, r5, lsl #4
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
  tmpccmr1 |= (TIM_ICFilter << 12);
 80010da:	ea41 3106 	orr.w	r1, r1, r6, lsl #12
  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
  tmpccer |= (TIM_ICPolarity << 4);

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 80010de:	6199      	str	r1, [r3, #24]
  TIMx->CCER = tmpccer;
 80010e0:	621a      	str	r2, [r3, #32]
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint16_t InputTriggerSource)
{
  uint32_t tmpsmcr = 0;

   /* Get the TIMx SMCR register value */
   tmpsmcr = TIMx->SMCR;
 80010e2:	689a      	ldr	r2, [r3, #8]
   /* Reset the TS Bits */
   tmpsmcr &= ~TIM_SMCR_TS;
 80010e4:	f022 0270 	bic.w	r2, r2, #112	; 0x70
   /* Set the Input Trigger source and the slave mode*/
   tmpsmcr |= InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1;
 80010e8:	f042 0267 	orr.w	r2, r2, #103	; 0x67
   /* Write to TIMx SMCR */
   TIMx->SMCR = tmpsmcr;
 80010ec:	609a      	str	r2, [r3, #8]
 80010ee:	e7d7      	b.n	80010a0 <HAL_TIM_ConfigClockSource+0x78>
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint16_t InputTriggerSource)
{
  uint32_t tmpsmcr = 0;

   /* Get the TIMx SMCR register value */
   tmpsmcr = TIMx->SMCR;
 80010f0:	689a      	ldr	r2, [r3, #8]
   /* Reset the TS Bits */
   tmpsmcr &= ~TIM_SMCR_TS;
 80010f2:	f022 0270 	bic.w	r2, r2, #112	; 0x70
   /* Set the Input Trigger source and the slave mode*/
   tmpsmcr |= InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1;
 80010f6:	f042 0217 	orr.w	r2, r2, #23
   /* Write to TIMx SMCR */
   TIMx->SMCR = tmpsmcr;
 80010fa:	609a      	str	r2, [r3, #8]
 80010fc:	e7d0      	b.n	80010a0 <HAL_TIM_ConfigClockSource+0x78>
  tmpsmcr = htim->Instance->SMCR;
  tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
  htim->Instance->SMCR = tmpsmcr;

  switch (sClockSourceConfig->ClockSource)
 80010fe:	2c00      	cmp	r4, #0
 8001100:	d1ce      	bne.n	80010a0 <HAL_TIM_ConfigClockSource+0x78>
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint16_t InputTriggerSource)
{
  uint32_t tmpsmcr = 0;

   /* Get the TIMx SMCR register value */
   tmpsmcr = TIMx->SMCR;
 8001102:	689a      	ldr	r2, [r3, #8]
   /* Reset the TS Bits */
   tmpsmcr &= ~TIM_SMCR_TS;
 8001104:	f022 0270 	bic.w	r2, r2, #112	; 0x70
   /* Set the Input Trigger source and the slave mode*/
   tmpsmcr |= InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1;
 8001108:	f042 0207 	orr.w	r2, r2, #7
   /* Write to TIMx SMCR */
   TIMx->SMCR = tmpsmcr;
 800110c:	609a      	str	r2, [r3, #8]
 800110e:	e7c7      	b.n	80010a0 <HAL_TIM_ConfigClockSource+0x78>
  {
  case TIM_CLOCKSOURCE_INTERNAL:
    {
      assert_param(IS_TIM_INSTANCE(htim->Instance));
      /* Disable slave mode to clock the prescaler directly with the internal clock */
      htim->Instance->SMCR &= ~TIM_SMCR_SMS;
 8001110:	689a      	ldr	r2, [r3, #8]
 8001112:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8001116:	f022 0207 	bic.w	r2, r2, #7
 800111a:	609a      	str	r2, [r3, #8]
    }
    break;
 800111c:	e7c0      	b.n	80010a0 <HAL_TIM_ConfigClockSource+0x78>
void TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler,
                       uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
{
  uint32_t tmpsmcr = 0;

  tmpsmcr = TIMx->SMCR;
 800111e:	689c      	ldr	r4, [r3, #8]
 8001120:	688a      	ldr	r2, [r1, #8]
 8001122:	684d      	ldr	r5, [r1, #4]

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8)));
 8001124:	68ce      	ldr	r6, [r1, #12]
 8001126:	432a      	orrs	r2, r5
 8001128:	f424 417f 	bic.w	r1, r4, #65280	; 0xff00
 800112c:	430a      	orrs	r2, r1
 800112e:	ea42 2206 	orr.w	r2, r2, r6, lsl #8

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8001132:	609a      	str	r2, [r3, #8]
      TIM_ETR_SetConfig(htim->Instance,
                        sClockSourceConfig->ClockPrescaler,
                        sClockSourceConfig->ClockPolarity,
                        sClockSourceConfig->ClockFilter);
      /* Get the TIMx SMCR register value */
      tmpsmcr = htim->Instance->SMCR;
 8001134:	689a      	ldr	r2, [r3, #8]
      /* Reset the SMS and TS Bits */
      tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
 8001136:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800113a:	f022 0277 	bic.w	r2, r2, #119	; 0x77
      /* Select the External clock mode1 and the ETRF trigger */
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
 800113e:	f042 0277 	orr.w	r2, r2, #119	; 0x77
      /* Write to TIMx SMCR */
      htim->Instance->SMCR = tmpsmcr;
 8001142:	609a      	str	r2, [r3, #8]
    }
    break;
 8001144:	e7ac      	b.n	80010a0 <HAL_TIM_ConfigClockSource+0x78>
{
  uint32_t tmpccmr1 = 0;
  uint32_t tmpccer = 0;

  /* Disable the Channel 1: Reset the CC1E Bit */
  tmpccer = TIMx->CCER;
 8001146:	6a1a      	ldr	r2, [r3, #32]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8001148:	6a1c      	ldr	r4, [r3, #32]

      /* Check TI1 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI1_ConfigInputStage(htim->Instance,
 800114a:	684e      	ldr	r6, [r1, #4]
 800114c:	68cd      	ldr	r5, [r1, #12]
  uint32_t tmpccmr1 = 0;
  uint32_t tmpccer = 0;

  /* Disable the Channel 1: Reset the CC1E Bit */
  tmpccer = TIMx->CCER;
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800114e:	f024 0401 	bic.w	r4, r4, #1
 8001152:	621c      	str	r4, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 8001154:	6999      	ldr	r1, [r3, #24]
  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
  tmpccmr1 |= (TIM_ICFilter << 4);

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8001156:	f022 020a 	bic.w	r2, r2, #10
  tmpccer = TIMx->CCER;
  TIMx->CCER &= ~TIM_CCER_CC1E;
  tmpccmr1 = TIMx->CCMR1;

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 800115a:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4);

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
  tmpccer |= TIM_ICPolarity;
 800115e:	4332      	orrs	r2, r6
  TIMx->CCER &= ~TIM_CCER_CC1E;
  tmpccmr1 = TIMx->CCMR1;

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
  tmpccmr1 |= (TIM_ICFilter << 4);
 8001160:	ea41 1105 	orr.w	r1, r1, r5, lsl #4
  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
  tmpccer |= TIM_ICPolarity;

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 8001164:	6199      	str	r1, [r3, #24]
  TIMx->CCER = tmpccer;
 8001166:	621a      	str	r2, [r3, #32]
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint16_t InputTriggerSource)
{
  uint32_t tmpsmcr = 0;

   /* Get the TIMx SMCR register value */
   tmpsmcr = TIMx->SMCR;
 8001168:	689a      	ldr	r2, [r3, #8]
   /* Reset the TS Bits */
   tmpsmcr &= ~TIM_SMCR_TS;
 800116a:	f022 0270 	bic.w	r2, r2, #112	; 0x70
   /* Set the Input Trigger source and the slave mode*/
   tmpsmcr |= InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1;
 800116e:	f042 0247 	orr.w	r2, r2, #71	; 0x47
   /* Write to TIMx SMCR */
   TIMx->SMCR = tmpsmcr;
 8001172:	609a      	str	r2, [r3, #8]
 8001174:	e794      	b.n	80010a0 <HAL_TIM_ConfigClockSource+0x78>
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint16_t InputTriggerSource)
{
  uint32_t tmpsmcr = 0;

   /* Get the TIMx SMCR register value */
   tmpsmcr = TIMx->SMCR;
 8001176:	689a      	ldr	r2, [r3, #8]
   /* Reset the TS Bits */
   tmpsmcr &= ~TIM_SMCR_TS;
 8001178:	f022 0270 	bic.w	r2, r2, #112	; 0x70
   /* Set the Input Trigger source and the slave mode*/
   tmpsmcr |= InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1;
 800117c:	f042 0227 	orr.w	r2, r2, #39	; 0x27
   /* Write to TIMx SMCR */
   TIMx->SMCR = tmpsmcr;
 8001180:	609a      	str	r2, [r3, #8]
 8001182:	e78d      	b.n	80010a0 <HAL_TIM_ConfigClockSource+0x78>
{
  uint32_t tmpccmr1 = 0;
  uint32_t tmpccer = 0;

  /* Disable the Channel 1: Reset the CC1E Bit */
  tmpccer = TIMx->CCER;
 8001184:	6a1a      	ldr	r2, [r3, #32]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8001186:	6a1c      	ldr	r4, [r3, #32]

      /* Check TI1 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI1_ConfigInputStage(htim->Instance,
 8001188:	684e      	ldr	r6, [r1, #4]
 800118a:	68cd      	ldr	r5, [r1, #12]
  uint32_t tmpccmr1 = 0;
  uint32_t tmpccer = 0;

  /* Disable the Channel 1: Reset the CC1E Bit */
  tmpccer = TIMx->CCER;
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800118c:	f024 0401 	bic.w	r4, r4, #1
 8001190:	621c      	str	r4, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 8001192:	6999      	ldr	r1, [r3, #24]
  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
  tmpccmr1 |= (TIM_ICFilter << 4);

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8001194:	f022 020a 	bic.w	r2, r2, #10
  tmpccer = TIMx->CCER;
  TIMx->CCER &= ~TIM_CCER_CC1E;
  tmpccmr1 = TIMx->CCMR1;

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8001198:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4);

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
  tmpccer |= TIM_ICPolarity;
 800119c:	4332      	orrs	r2, r6
  TIMx->CCER &= ~TIM_CCER_CC1E;
  tmpccmr1 = TIMx->CCMR1;

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
  tmpccmr1 |= (TIM_ICFilter << 4);
 800119e:	ea41 1105 	orr.w	r1, r1, r5, lsl #4
  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
  tmpccer |= TIM_ICPolarity;

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 80011a2:	6199      	str	r1, [r3, #24]
  TIMx->CCER = tmpccer;
 80011a4:	621a      	str	r2, [r3, #32]
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint16_t InputTriggerSource)
{
  uint32_t tmpsmcr = 0;

   /* Get the TIMx SMCR register value */
   tmpsmcr = TIMx->SMCR;
 80011a6:	689a      	ldr	r2, [r3, #8]
   /* Reset the TS Bits */
   tmpsmcr &= ~TIM_SMCR_TS;
 80011a8:	f022 0270 	bic.w	r2, r2, #112	; 0x70
   /* Set the Input Trigger source and the slave mode*/
   tmpsmcr |= InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1;
 80011ac:	f042 0257 	orr.w	r2, r2, #87	; 0x57
   /* Write to TIMx SMCR */
   TIMx->SMCR = tmpsmcr;
 80011b0:	609a      	str	r2, [r3, #8]
 80011b2:	e775      	b.n	80010a0 <HAL_TIM_ConfigClockSource+0x78>
 80011b4:	fffe0088 	.word	0xfffe0088

080011b8 <TIM_Base_SetConfig>:
{
  uint32_t tmpcr1 = 0;
  tmpcr1 = TIMx->CR1;

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80011b8:	4a26      	ldr	r2, [pc, #152]	; (8001254 <TIM_Base_SetConfig+0x9c>)
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
  uint32_t tmpcr1 = 0;
  tmpcr1 = TIMx->CR1;
 80011ba:	6803      	ldr	r3, [r0, #0]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80011bc:	4290      	cmp	r0, r2
  * @param  TIMx TIM peripheral
  * @param  Structure TIM Base configuration structure
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
 80011be:	b4f0      	push	{r4, r5, r6, r7}
  uint32_t tmpcr1 = 0;
  tmpcr1 = TIMx->CR1;

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80011c0:	d034      	beq.n	800122c <TIM_Base_SetConfig+0x74>
 80011c2:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 80011c6:	d014      	beq.n	80011f2 <TIM_Base_SetConfig+0x3a>
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
    tmpcr1 |= Structure->CounterMode;
  }

  if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 80011c8:	f502 52a0 	add.w	r2, r2, #5120	; 0x1400
 80011cc:	4290      	cmp	r0, r2
 80011ce:	d014      	beq.n	80011fa <TIM_Base_SetConfig+0x42>
 80011d0:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80011d4:	4290      	cmp	r0, r2
 80011d6:	d010      	beq.n	80011fa <TIM_Base_SetConfig+0x42>
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
  }

  /* Set the auto-reload preload */
  tmpcr1 &= ~TIM_CR1_ARPE;
  tmpcr1 |= (uint32_t)Structure->AutoReloadPreload;
 80011d8:	694a      	ldr	r2, [r1, #20]

  TIMx->CR1 = tmpcr1;

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 80011da:	688c      	ldr	r4, [r1, #8]

  /* Set the Prescaler value */
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 80011dc:	6809      	ldr	r1, [r1, #0]
    tmpcr1 &= ~TIM_CR1_CKD;
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
  }

  /* Set the auto-reload preload */
  tmpcr1 &= ~TIM_CR1_ARPE;
 80011de:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  tmpcr1 |= (uint32_t)Structure->AutoReloadPreload;
 80011e2:	4313      	orrs	r3, r2

  TIMx->CR1 = tmpcr1;
 80011e4:	6003      	str	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 80011e6:	62c4      	str	r4, [r0, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 80011e8:	6281      	str	r1, [r0, #40]	; 0x28
    TIMx->RCR = Structure->RepetitionCounter;
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter(only for TIM1 and TIM8) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 80011ea:	2301      	movs	r3, #1
 80011ec:	6143      	str	r3, [r0, #20]
}
 80011ee:	bcf0      	pop	{r4, r5, r6, r7}
 80011f0:	4770      	bx	lr
  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
    tmpcr1 |= Structure->CounterMode;
 80011f2:	684a      	ldr	r2, [r1, #4]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 80011f4:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 80011f8:	4313      	orrs	r3, r2

  if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80011fa:	68ca      	ldr	r2, [r1, #12]
  }

  /* Set the auto-reload preload */
  tmpcr1 &= ~TIM_CR1_ARPE;
  tmpcr1 |= (uint32_t)Structure->AutoReloadPreload;
 80011fc:	694c      	ldr	r4, [r1, #20]
  TIMx->ARR = (uint32_t)Structure->Period ;

  /* Set the Prescaler value */
  TIMx->PSC = (uint32_t)Structure->Prescaler;

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 80011fe:	4d16      	ldr	r5, [pc, #88]	; (8001258 <TIM_Base_SetConfig+0xa0>)
  tmpcr1 |= (uint32_t)Structure->AutoReloadPreload;

  TIMx->CR1 = tmpcr1;

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8001200:	688f      	ldr	r7, [r1, #8]

  /* Set the Prescaler value */
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 8001202:	680e      	ldr	r6, [r1, #0]
  }

  if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 8001204:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8001208:	4313      	orrs	r3, r2
  }

  /* Set the auto-reload preload */
  tmpcr1 &= ~TIM_CR1_ARPE;
 800120a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  tmpcr1 |= (uint32_t)Structure->AutoReloadPreload;
 800120e:	4323      	orrs	r3, r4
  TIMx->ARR = (uint32_t)Structure->Period ;

  /* Set the Prescaler value */
  TIMx->PSC = (uint32_t)Structure->Prescaler;

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8001210:	42a8      	cmp	r0, r5

  /* Set the auto-reload preload */
  tmpcr1 &= ~TIM_CR1_ARPE;
  tmpcr1 |= (uint32_t)Structure->AutoReloadPreload;

  TIMx->CR1 = tmpcr1;
 8001212:	6003      	str	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8001214:	62c7      	str	r7, [r0, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 8001216:	6286      	str	r6, [r0, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8001218:	d002      	beq.n	8001220 <TIM_Base_SetConfig+0x68>
 800121a:	4b10      	ldr	r3, [pc, #64]	; (800125c <TIM_Base_SetConfig+0xa4>)
 800121c:	4298      	cmp	r0, r3
 800121e:	d1e4      	bne.n	80011ea <TIM_Base_SetConfig+0x32>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 8001220:	690b      	ldr	r3, [r1, #16]
 8001222:	6303      	str	r3, [r0, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter(only for TIM1 and TIM8) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 8001224:	2301      	movs	r3, #1
 8001226:	6143      	str	r3, [r0, #20]
}
 8001228:	bcf0      	pop	{r4, r5, r6, r7}
 800122a:	4770      	bx	lr
  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
    tmpcr1 |= Structure->CounterMode;
 800122c:	684c      	ldr	r4, [r1, #4]

  if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800122e:	68ca      	ldr	r2, [r1, #12]
  }

  /* Set the auto-reload preload */
  tmpcr1 &= ~TIM_CR1_ARPE;
  tmpcr1 |= (uint32_t)Structure->AutoReloadPreload;
 8001230:	694d      	ldr	r5, [r1, #20]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8001232:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8001236:	431c      	orrs	r4, r3
  }

  if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 8001238:	f424 7440 	bic.w	r4, r4, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800123c:	4322      	orrs	r2, r4
  }

  /* Set the auto-reload preload */
  tmpcr1 &= ~TIM_CR1_ARPE;
 800123e:	f022 0280 	bic.w	r2, r2, #128	; 0x80
  tmpcr1 |= (uint32_t)Structure->AutoReloadPreload;
 8001242:	432a      	orrs	r2, r5

  TIMx->CR1 = tmpcr1;
 8001244:	6002      	str	r2, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8001246:	688b      	ldr	r3, [r1, #8]
 8001248:	62c3      	str	r3, [r0, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 800124a:	680b      	ldr	r3, [r1, #0]
 800124c:	6283      	str	r3, [r0, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 800124e:	690b      	ldr	r3, [r1, #16]
 8001250:	6303      	str	r3, [r0, #48]	; 0x30
 8001252:	e7e7      	b.n	8001224 <TIM_Base_SetConfig+0x6c>
 8001254:	40012c00 	.word	0x40012c00
 8001258:	40014000 	.word	0x40014000
 800125c:	40014400 	.word	0x40014400

08001260 <HAL_TIM_Base_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
  /* Check the TIM handle allocation */
  if(htim == NULL)
 8001260:	b1b8      	cbz	r0, 8001292 <HAL_TIM_Base_Init+0x32>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if(htim->State == HAL_TIM_STATE_RESET)
 8001262:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
  *       Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
 8001266:	b510      	push	{r4, lr}
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if(htim->State == HAL_TIM_STATE_RESET)
 8001268:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800126c:	4604      	mov	r4, r0
 800126e:	b15b      	cbz	r3, 8001288 <HAL_TIM_Base_Init+0x28>
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_TIM_Base_MspInit(htim);
  }

  /* Set the TIM state */
  htim->State= HAL_TIM_STATE_BUSY;
 8001270:	2302      	movs	r3, #2
 8001272:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d

  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8001276:	6820      	ldr	r0, [r4, #0]
 8001278:	1d21      	adds	r1, r4, #4
 800127a:	f7ff ff9d 	bl	80011b8 <TIM_Base_SetConfig>

  /* Initialize the TIM state*/
  htim->State= HAL_TIM_STATE_READY;
 800127e:	2301      	movs	r3, #1
 8001280:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d

  return HAL_OK;
 8001284:	2000      	movs	r0, #0
 8001286:	bd10      	pop	{r4, pc}
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if(htim->State == HAL_TIM_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 8001288:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c

    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_TIM_Base_MspInit(htim);
 800128c:	f000 fa66 	bl	800175c <HAL_TIM_Base_MspInit>
 8001290:	e7ee      	b.n	8001270 <HAL_TIM_Base_Init+0x10>
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
  /* Check the TIM handle allocation */
  if(htim == NULL)
  {
    return HAL_ERROR;
 8001292:	2001      	movs	r0, #1
 8001294:	4770      	bx	lr
 8001296:	bf00      	nop

08001298 <HAL_TIM_PWM_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
{
  /* Check the TIM handle allocation */
  if(htim == NULL)
 8001298:	b1b8      	cbz	r0, 80012ca <HAL_TIM_PWM_Init+0x32>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if(htim->State == HAL_TIM_STATE_RESET)
 800129a:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
  *       Ex: call @ref HAL_TIM_PWM_DeInit() before HAL_TIM_PWM_Init()
  * @param  htim TIM handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
{
 800129e:	b510      	push	{r4, lr}
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if(htim->State == HAL_TIM_STATE_RESET)
 80012a0:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80012a4:	4604      	mov	r4, r0
 80012a6:	b15b      	cbz	r3, 80012c0 <HAL_TIM_PWM_Init+0x28>
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIM_PWM_MspInit(htim);
  }

  /* Set the TIM state */
  htim->State= HAL_TIM_STATE_BUSY;
 80012a8:	2302      	movs	r3, #2
 80012aa:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d

  /* Init the base time for the PWM */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 80012ae:	6820      	ldr	r0, [r4, #0]
 80012b0:	1d21      	adds	r1, r4, #4
 80012b2:	f7ff ff81 	bl	80011b8 <TIM_Base_SetConfig>

  /* Initialize the TIM state*/
  htim->State= HAL_TIM_STATE_READY;
 80012b6:	2301      	movs	r3, #1
 80012b8:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d

  return HAL_OK;
 80012bc:	2000      	movs	r0, #0
 80012be:	bd10      	pop	{r4, pc}
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if(htim->State == HAL_TIM_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 80012c0:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c

    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIM_PWM_MspInit(htim);
 80012c4:	f7ff fe86 	bl	8000fd4 <HAL_TIM_PWM_MspInit>
 80012c8:	e7ee      	b.n	80012a8 <HAL_TIM_PWM_Init+0x10>
HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
{
  /* Check the TIM handle allocation */
  if(htim == NULL)
  {
    return HAL_ERROR;
 80012ca:	2001      	movs	r0, #1
 80012cc:	4770      	bx	lr
 80012ce:	bf00      	nop

080012d0 <TIM_OC2_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */
void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 80012d0:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 80012d2:	6a04      	ldr	r4, [r0, #32]
  tmpccmrx |= (OC_Config->OCMode << 8);

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC2P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 4);
 80012d4:	f8d1 e008 	ldr.w	lr, [r1, #8]
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR1_OC2M;
  tmpccmrx &= ~TIM_CCMR1_CC2S;

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);
 80012d8:	680f      	ldr	r7, [r1, #0]
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC2P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 4);

  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 80012da:	4e17      	ldr	r6, [pc, #92]	; (8001338 <TIM_OC2_SetConfig+0x68>)
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 80012dc:	f024 0410 	bic.w	r4, r4, #16
 80012e0:	6204      	str	r4, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80012e2:	6a04      	ldr	r4, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80012e4:	6845      	ldr	r5, [r0, #4]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 80012e6:	6982      	ldr	r2, [r0, #24]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR1_OC2M;
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 80012e8:	f022 7380 	bic.w	r3, r2, #16777216	; 0x1000000
 80012ec:	f423 43e6 	bic.w	r3, r3, #29440	; 0x7300

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC2P;
 80012f0:	f024 0220 	bic.w	r2, r4, #32
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 4);

  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 80012f4:	42b0      	cmp	r0, r6
  tmpccmrx |= (OC_Config->OCMode << 8);

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC2P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 4);
 80012f6:	ea42 120e 	orr.w	r2, r2, lr, lsl #4
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR1_OC2M;
  tmpccmrx &= ~TIM_CCMR1_CC2S;

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);
 80012fa:	ea43 2307 	orr.w	r3, r3, r7, lsl #8
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC2P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 4);

  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 80012fe:	d00b      	beq.n	8001318 <TIM_OC2_SetConfig+0x48>
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC2NE;

  }

  if(IS_TIM_BREAK_INSTANCE(TIMx))
 8001300:	4c0e      	ldr	r4, [pc, #56]	; (800133c <TIM_OC2_SetConfig+0x6c>)
 8001302:	42a0      	cmp	r0, r4
 8001304:	d00f      	beq.n	8001326 <TIM_OC2_SetConfig+0x56>
 8001306:	4c0e      	ldr	r4, [pc, #56]	; (8001340 <TIM_OC2_SetConfig+0x70>)
 8001308:	42a0      	cmp	r0, r4
 800130a:	d00c      	beq.n	8001326 <TIM_OC2_SetConfig+0x56>

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR2 = OC_Config->Pulse;
 800130c:	6849      	ldr	r1, [r1, #4]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 2);
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800130e:	6045      	str	r5, [r0, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 8001310:	6183      	str	r3, [r0, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR2 = OC_Config->Pulse;
 8001312:	6381      	str	r1, [r0, #56]	; 0x38

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8001314:	6202      	str	r2, [r0, #32]
}
 8001316:	bdf0      	pop	{r4, r5, r6, r7, pc}
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC2NP;
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 4);
 8001318:	68cc      	ldr	r4, [r1, #12]
  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC2NP;
 800131a:	f022 0280 	bic.w	r2, r2, #128	; 0x80
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 4);
 800131e:	ea42 1204 	orr.w	r2, r2, r4, lsl #4
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC2NE;
 8001322:	f022 0240 	bic.w	r2, r2, #64	; 0x40

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS2;
    tmpcr2 &= ~TIM_CR2_OIS2N;
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 2);
 8001326:	694e      	ldr	r6, [r1, #20]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 2);
 8001328:	698c      	ldr	r4, [r1, #24]
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS2;
    tmpcr2 &= ~TIM_CR2_OIS2N;
 800132a:	f425 6540 	bic.w	r5, r5, #3072	; 0xc00
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 2);
 800132e:	ea45 0586 	orr.w	r5, r5, r6, lsl #2
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 2);
 8001332:	ea45 0584 	orr.w	r5, r5, r4, lsl #2
 8001336:	e7e9      	b.n	800130c <TIM_OC2_SetConfig+0x3c>
 8001338:	40012c00 	.word	0x40012c00
 800133c:	40014000 	.word	0x40014000
 8001340:	40014400 	.word	0x40014400

08001344 <HAL_TIM_PWM_ConfigChannel>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim,
                                            TIM_OC_InitTypeDef* sConfig,
                                            uint32_t Channel)
{
 8001344:	b538      	push	{r3, r4, r5, lr}
  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));

  /* Process Locked */
  __HAL_LOCK(htim);
 8001346:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 800134a:	2b01      	cmp	r3, #1
 800134c:	d02f      	beq.n	80013ae <HAL_TIM_PWM_ConfigChannel+0x6a>
 800134e:	460d      	mov	r5, r1

  htim->State = HAL_TIM_STATE_BUSY;
 8001350:	2302      	movs	r3, #2
  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));

  /* Process Locked */
  __HAL_LOCK(htim);
 8001352:	2101      	movs	r1, #1
 8001354:	4604      	mov	r4, r0
 8001356:	f880 103c 	strb.w	r1, [r0, #60]	; 0x3c

  htim->State = HAL_TIM_STATE_BUSY;
 800135a:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d

  switch (Channel)
 800135e:	2a14      	cmp	r2, #20
 8001360:	d81e      	bhi.n	80013a0 <HAL_TIM_PWM_ConfigChannel+0x5c>
 8001362:	e8df f002 	tbb	[pc, r2]
 8001366:	1d39      	.short	0x1d39
 8001368:	1d4b1d1d 	.word	0x1d4b1d1d
 800136c:	1d5e1d1d 	.word	0x1d5e1d1d
 8001370:	1d0b1d1d 	.word	0x1d0b1d1d
 8001374:	1d701d1d 	.word	0x1d701d1d
 8001378:	1d1d      	.short	0x1d1d
 800137a:	26          	.byte	0x26
 800137b:	00          	.byte	0x00
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));

      /* Configure the Channel 4 in PWM mode */
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 800137c:	4629      	mov	r1, r5
 800137e:	6800      	ldr	r0, [r0, #0]
 8001380:	f7ff fd88 	bl	8000e94 <TIM_OC4_SetConfig>

      /* Set the Preload enable bit for channel4 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 8001384:	6823      	ldr	r3, [r4, #0]

     /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;
 8001386:	6928      	ldr	r0, [r5, #16]

      /* Configure the Channel 4 in PWM mode */
      TIM_OC4_SetConfig(htim->Instance, sConfig);

      /* Set the Preload enable bit for channel4 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 8001388:	69d9      	ldr	r1, [r3, #28]
 800138a:	f441 6100 	orr.w	r1, r1, #2048	; 0x800
 800138e:	61d9      	str	r1, [r3, #28]

     /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
 8001390:	69d9      	ldr	r1, [r3, #28]
 8001392:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 8001396:	61d9      	str	r1, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;
 8001398:	69da      	ldr	r2, [r3, #28]
 800139a:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 800139e:	61da      	str	r2, [r3, #28]

    default:
    break;
  }

  htim->State = HAL_TIM_STATE_READY;
 80013a0:	2301      	movs	r3, #1

  __HAL_UNLOCK(htim);
 80013a2:	2000      	movs	r0, #0

    default:
    break;
  }

  htim->State = HAL_TIM_STATE_READY;
 80013a4:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d

  __HAL_UNLOCK(htim);
 80013a8:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c

  return HAL_OK;
 80013ac:	bd38      	pop	{r3, r4, r5, pc}
  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));

  /* Process Locked */
  __HAL_LOCK(htim);
 80013ae:	2002      	movs	r0, #2
  htim->State = HAL_TIM_STATE_READY;

  __HAL_UNLOCK(htim);

  return HAL_OK;
}
 80013b0:	bd38      	pop	{r3, r4, r5, pc}
    {
       /* Check the parameters */
      assert_param(IS_TIM_CC6_INSTANCE(htim->Instance));

     /* Configure the Channel 5 in PWM mode */
      TIM_OC6_SetConfig(htim->Instance, sConfig);
 80013b2:	4629      	mov	r1, r5
 80013b4:	6800      	ldr	r0, [r0, #0]
 80013b6:	f7ff fdcd 	bl	8000f54 <TIM_OC6_SetConfig>

      /* Set the Preload enable bit for channel6 */
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
 80013ba:	6823      	ldr	r3, [r4, #0]

     /* Configure the Output Fast mode */
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8;
 80013bc:	6928      	ldr	r0, [r5, #16]

     /* Configure the Channel 5 in PWM mode */
      TIM_OC6_SetConfig(htim->Instance, sConfig);

      /* Set the Preload enable bit for channel6 */
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
 80013be:	6d59      	ldr	r1, [r3, #84]	; 0x54
 80013c0:	f441 6100 	orr.w	r1, r1, #2048	; 0x800
 80013c4:	6559      	str	r1, [r3, #84]	; 0x54

     /* Configure the Output Fast mode */
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
 80013c6:	6d59      	ldr	r1, [r3, #84]	; 0x54
 80013c8:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 80013cc:	6559      	str	r1, [r3, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8;
 80013ce:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 80013d0:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 80013d4:	655a      	str	r2, [r3, #84]	; 0x54
    }
    break;
 80013d6:	e7e3      	b.n	80013a0 <HAL_TIM_PWM_ConfigChannel+0x5c>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));

      /* Configure the Channel 1 in PWM mode */
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 80013d8:	4629      	mov	r1, r5
 80013da:	6800      	ldr	r0, [r0, #0]
 80013dc:	f7ff fcea 	bl	8000db4 <TIM_OC1_SetConfig>

      /* Set the Preload enable bit for channel1 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 80013e0:	6823      	ldr	r3, [r4, #0]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 80013e2:	692a      	ldr	r2, [r5, #16]

      /* Configure the Channel 1 in PWM mode */
      TIM_OC1_SetConfig(htim->Instance, sConfig);

      /* Set the Preload enable bit for channel1 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 80013e4:	6999      	ldr	r1, [r3, #24]
 80013e6:	f041 0108 	orr.w	r1, r1, #8
 80013ea:	6199      	str	r1, [r3, #24]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 80013ec:	6999      	ldr	r1, [r3, #24]
 80013ee:	f021 0104 	bic.w	r1, r1, #4
 80013f2:	6199      	str	r1, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 80013f4:	6999      	ldr	r1, [r3, #24]
 80013f6:	430a      	orrs	r2, r1
 80013f8:	619a      	str	r2, [r3, #24]
    }
    break;
 80013fa:	e7d1      	b.n	80013a0 <HAL_TIM_PWM_ConfigChannel+0x5c>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));

      /* Configure the Channel 2 in PWM mode */
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 80013fc:	4629      	mov	r1, r5
 80013fe:	6800      	ldr	r0, [r0, #0]
 8001400:	f7ff ff66 	bl	80012d0 <TIM_OC2_SetConfig>

      /* Set the Preload enable bit for channel2 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 8001404:	6823      	ldr	r3, [r4, #0]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
 8001406:	6928      	ldr	r0, [r5, #16]

      /* Configure the Channel 2 in PWM mode */
      TIM_OC2_SetConfig(htim->Instance, sConfig);

      /* Set the Preload enable bit for channel2 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 8001408:	6999      	ldr	r1, [r3, #24]
 800140a:	f441 6100 	orr.w	r1, r1, #2048	; 0x800
 800140e:	6199      	str	r1, [r3, #24]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
 8001410:	6999      	ldr	r1, [r3, #24]
 8001412:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 8001416:	6199      	str	r1, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
 8001418:	699a      	ldr	r2, [r3, #24]
 800141a:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 800141e:	619a      	str	r2, [r3, #24]
    }
    break;
 8001420:	e7be      	b.n	80013a0 <HAL_TIM_PWM_ConfigChannel+0x5c>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));

      /* Configure the Channel 3 in PWM mode */
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 8001422:	4629      	mov	r1, r5
 8001424:	6800      	ldr	r0, [r0, #0]
 8001426:	f7ff fcfb 	bl	8000e20 <TIM_OC3_SetConfig>

      /* Set the Preload enable bit for channel3 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 800142a:	6823      	ldr	r3, [r4, #0]

     /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 800142c:	692a      	ldr	r2, [r5, #16]

      /* Configure the Channel 3 in PWM mode */
      TIM_OC3_SetConfig(htim->Instance, sConfig);

      /* Set the Preload enable bit for channel3 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 800142e:	69d9      	ldr	r1, [r3, #28]
 8001430:	f041 0108 	orr.w	r1, r1, #8
 8001434:	61d9      	str	r1, [r3, #28]

     /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 8001436:	69d9      	ldr	r1, [r3, #28]
 8001438:	f021 0104 	bic.w	r1, r1, #4
 800143c:	61d9      	str	r1, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 800143e:	69d9      	ldr	r1, [r3, #28]
 8001440:	430a      	orrs	r2, r1
 8001442:	61da      	str	r2, [r3, #28]
    }
    break;
 8001444:	e7ac      	b.n	80013a0 <HAL_TIM_PWM_ConfigChannel+0x5c>
    {
       /* Check the parameters */
      assert_param(IS_TIM_CC5_INSTANCE(htim->Instance));

     /* Configure the Channel 5 in PWM mode */
      TIM_OC5_SetConfig(htim->Instance, sConfig);
 8001446:	4629      	mov	r1, r5
 8001448:	6800      	ldr	r0, [r0, #0]
 800144a:	f7ff fd53 	bl	8000ef4 <TIM_OC5_SetConfig>

      /* Set the Preload enable bit for channel5*/
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
 800144e:	6823      	ldr	r3, [r4, #0]

     /* Configure the Output Fast mode */
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
      htim->Instance->CCMR3 |= sConfig->OCFastMode;
 8001450:	692a      	ldr	r2, [r5, #16]

     /* Configure the Channel 5 in PWM mode */
      TIM_OC5_SetConfig(htim->Instance, sConfig);

      /* Set the Preload enable bit for channel5*/
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
 8001452:	6d59      	ldr	r1, [r3, #84]	; 0x54
 8001454:	f041 0108 	orr.w	r1, r1, #8
 8001458:	6559      	str	r1, [r3, #84]	; 0x54

     /* Configure the Output Fast mode */
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
 800145a:	6d59      	ldr	r1, [r3, #84]	; 0x54
 800145c:	f021 0104 	bic.w	r1, r1, #4
 8001460:	6559      	str	r1, [r3, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode;
 8001462:	6d59      	ldr	r1, [r3, #84]	; 0x54
 8001464:	430a      	orrs	r2, r1
 8001466:	655a      	str	r2, [r3, #84]	; 0x54
    }
    break;
 8001468:	e79a      	b.n	80013a0 <HAL_TIM_PWM_ConfigChannel+0x5c>
 800146a:	bf00      	nop

0800146c <HAL_TIMEx_MasterConfigSynchronization>:
  assert_param(IS_TIM_SYNCHRO_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 800146c:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8001470:	2b01      	cmp	r3, #1
 8001472:	d017      	beq.n	80014a4 <HAL_TIMEx_MasterConfigSynchronization+0x38>

 /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 8001474:	6803      	ldr	r3, [r0, #0]
  *         mode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,
                                                      TIM_MasterConfigTypeDef * sMasterConfig)
{
 8001476:	b470      	push	{r4, r5, r6}

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 8001478:	4c0e      	ldr	r4, [pc, #56]	; (80014b4 <HAL_TIMEx_MasterConfigSynchronization+0x48>)
 800147a:	42a3      	cmp	r3, r4
 800147c:	4602      	mov	r2, r0

  /* Check input state */
  __HAL_LOCK(htim);

 /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 800147e:	6858      	ldr	r0, [r3, #4]

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;
 8001480:	689e      	ldr	r6, [r3, #8]

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 8001482:	d011      	beq.n	80014a8 <HAL_TIMEx_MasterConfigSynchronization+0x3c>
  }

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8001484:	680d      	ldr	r5, [r1, #0]

  /* Reset the MSM Bit */
  tmpsmcr &= ~TIM_SMCR_MSM;
  /* Set master mode */
  tmpsmcr |= sMasterConfig->MasterSlaveMode;
 8001486:	688c      	ldr	r4, [r1, #8]
    /* Select the TRGO2 source*/
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
  }

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
 8001488:	f020 0070 	bic.w	r0, r0, #112	; 0x70
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;

  /* Reset the MSM Bit */
  tmpsmcr &= ~TIM_SMCR_MSM;
 800148c:	f026 0180 	bic.w	r1, r6, #128	; 0x80
  }

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8001490:	4328      	orrs	r0, r5

  /* Reset the MSM Bit */
  tmpsmcr &= ~TIM_SMCR_MSM;
  /* Set master mode */
  tmpsmcr |= sMasterConfig->MasterSlaveMode;
 8001492:	4321      	orrs	r1, r4
  htim->Instance->CR2 = tmpcr2;

  /* Update TIMx SMCR */
  htim->Instance->SMCR = tmpsmcr;

  __HAL_UNLOCK(htim);
 8001494:	2400      	movs	r4, #0
  tmpsmcr &= ~TIM_SMCR_MSM;
  /* Set master mode */
  tmpsmcr |= sMasterConfig->MasterSlaveMode;

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;
 8001496:	6058      	str	r0, [r3, #4]
  /* Update TIMx SMCR */
  htim->Instance->SMCR = tmpsmcr;

  __HAL_UNLOCK(htim);

  return HAL_OK;
 8001498:	4620      	mov	r0, r4

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;

  /* Update TIMx SMCR */
  htim->Instance->SMCR = tmpsmcr;
 800149a:	6099      	str	r1, [r3, #8]

  __HAL_UNLOCK(htim);
 800149c:	f882 403c 	strb.w	r4, [r2, #60]	; 0x3c

  return HAL_OK;
}
 80014a0:	bc70      	pop	{r4, r5, r6}
 80014a2:	4770      	bx	lr
  assert_param(IS_TIM_SYNCHRO_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 80014a4:	2002      	movs	r0, #2
 80014a6:	4770      	bx	lr
    assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));

    /* Clear the MMS2 bits */
    tmpcr2 &= ~TIM_CR2_MMS2;
    /* Select the TRGO2 source*/
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 80014a8:	684c      	ldr	r4, [r1, #4]
  {
    /* Check the parameters */
    assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));

    /* Clear the MMS2 bits */
    tmpcr2 &= ~TIM_CR2_MMS2;
 80014aa:	f420 0070 	bic.w	r0, r0, #15728640	; 0xf00000
    /* Select the TRGO2 source*/
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 80014ae:	4320      	orrs	r0, r4
 80014b0:	e7e8      	b.n	8001484 <HAL_TIMEx_MasterConfigSynchronization+0x18>
 80014b2:	bf00      	nop
 80014b4:	40012c00 	.word	0x40012c00

080014b8 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 80014b8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80014ba:	b097      	sub	sp, #92	; 0x5c
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
  RCC_OscInitStruct.MSICalibrationValue = 0;
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 80014bc:	2302      	movs	r3, #2
  RCC_ClkInitTypeDef RCC_ClkInitStruct;

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
 80014be:	2201      	movs	r2, #1
  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
 80014c0:	2710      	movs	r7, #16
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
  RCC_OscInitStruct.MSICalibrationValue = 0;
 80014c2:	2600      	movs	r6, #0
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
 80014c4:	2560      	movs	r5, #96	; 0x60
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
  RCC_OscInitStruct.PLL.PLLN = 40;
 80014c6:	2428      	movs	r4, #40	; 0x28
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
 80014c8:	2107      	movs	r1, #7
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80014ca:	a805      	add	r0, sp, #20
  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
 80014cc:	9705      	str	r7, [sp, #20]
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
 80014ce:	920b      	str	r2, [sp, #44]	; 0x2c
  RCC_OscInitStruct.MSICalibrationValue = 0;
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
 80014d0:	9210      	str	r2, [sp, #64]	; 0x40

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
  RCC_OscInitStruct.MSICalibrationValue = 0;
 80014d2:	960c      	str	r6, [sp, #48]	; 0x30
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
 80014d4:	950d      	str	r5, [sp, #52]	; 0x34
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 80014d6:	930f      	str	r3, [sp, #60]	; 0x3c
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
  RCC_OscInitStruct.PLL.PLLN = 40;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
 80014d8:	9314      	str	r3, [sp, #80]	; 0x50
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
 80014da:	9315      	str	r3, [sp, #84]	; 0x54
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
  RCC_OscInitStruct.MSICalibrationValue = 0;
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
  RCC_OscInitStruct.PLL.PLLN = 40;
 80014dc:	9412      	str	r4, [sp, #72]	; 0x48
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
 80014de:	9113      	str	r1, [sp, #76]	; 0x4c
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80014e0:	f7ff f8fc 	bl	80006dc <HAL_RCC_OscConfig>
 80014e4:	b100      	cbz	r0, 80014e8 <SystemClock_Config+0x30>
 80014e6:	e7fe      	b.n	80014e6 <SystemClock_Config+0x2e>
 80014e8:	4603      	mov	r3, r0
    _Error_Handler(__FILE__, __LINE__);
  }

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80014ea:	240f      	movs	r4, #15
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80014ec:	2203      	movs	r2, #3
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 80014ee:	2104      	movs	r1, #4
 80014f0:	4668      	mov	r0, sp
    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 80014f2:	9302      	str	r3, [sp, #8]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 80014f4:	9303      	str	r3, [sp, #12]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 80014f6:	9304      	str	r3, [sp, #16]
    _Error_Handler(__FILE__, __LINE__);
  }

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80014f8:	9400      	str	r4, [sp, #0]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80014fa:	9201      	str	r2, [sp, #4]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 80014fc:	f7ff fb9e 	bl	8000c3c <HAL_RCC_ClockConfig>
 8001500:	b100      	cbz	r0, 8001504 <SystemClock_Config+0x4c>
 8001502:	e7fe      	b.n	8001502 <SystemClock_Config+0x4a>
    _Error_Handler(__FILE__, __LINE__);
  }

    /**Configure the main internal regulator output voltage 
    */
  if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
 8001504:	f44f 7000 	mov.w	r0, #512	; 0x200
 8001508:	f7fe ffe8 	bl	80004dc <HAL_PWREx_ControlVoltageScaling>
 800150c:	4604      	mov	r4, r0
 800150e:	b100      	cbz	r0, 8001512 <SystemClock_Config+0x5a>
 8001510:	e7fe      	b.n	8001510 <SystemClock_Config+0x58>
    _Error_Handler(__FILE__, __LINE__);
  }

    /**Configure the Systick interrupt time 
    */
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 8001512:	f7ff fc49 	bl	8000da8 <HAL_RCC_GetHCLKFreq>
 8001516:	4b08      	ldr	r3, [pc, #32]	; (8001538 <SystemClock_Config+0x80>)
 8001518:	fba3 3000 	umull	r3, r0, r3, r0
 800151c:	0980      	lsrs	r0, r0, #6
 800151e:	f7fe fecf 	bl	80002c0 <HAL_SYSTICK_Config>

    /**Configure the Systick 
    */
  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 8001522:	2004      	movs	r0, #4
 8001524:	f7fe fee6 	bl	80002f4 <HAL_SYSTICK_CLKSourceConfig>

  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 8001528:	4622      	mov	r2, r4
 800152a:	4621      	mov	r1, r4
 800152c:	f04f 30ff 	mov.w	r0, #4294967295
 8001530:	f7fe fe8e 	bl	8000250 <HAL_NVIC_SetPriority>
}
 8001534:	b017      	add	sp, #92	; 0x5c
 8001536:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001538:	10624dd3 	.word	0x10624dd3

0800153c <main>:
  * @brief  The application entry point.
  *
  * @retval None
  */
int main(void)
{
 800153c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8001540:	b091      	sub	sp, #68	; 0x44
  /* USER CODE END 1 */

  /* MCU Configuration----------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 8001542:	f7fe fe59 	bl	80001f8 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 8001546:	f7ff ffb7 	bl	80014b8 <SystemClock_Config>
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800154a:	4b5b      	ldr	r3, [pc, #364]	; (80016b8 <main+0x17c>)

  TIM_ClockConfigTypeDef sClockSourceConfig;
  TIM_MasterConfigTypeDef sMasterConfig;
  TIM_OC_InitTypeDef sConfigOC;

  htim2.Instance = TIM2;
 800154c:	4c5b      	ldr	r4, [pc, #364]	; (80016bc <main+0x180>)
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800154e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, LED1_Pin|GPIO_PIN_6, GPIO_PIN_RESET);
 8001550:	485b      	ldr	r0, [pc, #364]	; (80016c0 <main+0x184>)
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8001552:	f042 0201 	orr.w	r2, r2, #1
 8001556:	64da      	str	r2, [r3, #76]	; 0x4c
 8001558:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800155a:	f002 0201 	and.w	r2, r2, #1
 800155e:	9200      	str	r2, [sp, #0]
 8001560:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8001562:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001564:	f042 0202 	orr.w	r2, r2, #2
 8001568:	64da      	str	r2, [r3, #76]	; 0x4c
 800156a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800156c:	f003 0302 	and.w	r3, r3, #2

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, LED1_Pin|GPIO_PIN_6, GPIO_PIN_RESET);
 8001570:	2200      	movs	r2, #0

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8001572:	9301      	str	r3, [sp, #4]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, LED1_Pin|GPIO_PIN_6, GPIO_PIN_RESET);
 8001574:	2148      	movs	r1, #72	; 0x48

  /*Configure GPIO pins : LED1_Pin PB6 */
  GPIO_InitStruct.Pin = LED1_Pin|GPIO_PIN_6;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001576:	4615      	mov	r5, r2

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8001578:	9b01      	ldr	r3, [sp, #4]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, LED1_Pin|GPIO_PIN_6, GPIO_PIN_RESET);
 800157a:	f7fe ffa1 	bl	80004c0 <HAL_GPIO_WritePin>

  /*Configure GPIO pins : LED1_Pin PB6 */
  GPIO_InitStruct.Pin = LED1_Pin|GPIO_PIN_6;
 800157e:	2248      	movs	r2, #72	; 0x48
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8001580:	2301      	movs	r3, #1
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8001582:	a909      	add	r1, sp, #36	; 0x24
 8001584:	484e      	ldr	r0, [pc, #312]	; (80016c0 <main+0x184>)

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, LED1_Pin|GPIO_PIN_6, GPIO_PIN_RESET);

  /*Configure GPIO pins : LED1_Pin PB6 */
  GPIO_InitStruct.Pin = LED1_Pin|GPIO_PIN_6;
 8001586:	9209      	str	r2, [sp, #36]	; 0x24
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8001588:	930a      	str	r3, [sp, #40]	; 0x28
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800158a:	950b      	str	r5, [sp, #44]	; 0x2c
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800158c:	950c      	str	r5, [sp, #48]	; 0x30
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800158e:	f7fe fec3 	bl	8000318 <HAL_GPIO_Init>

  TIM_ClockConfigTypeDef sClockSourceConfig;
  TIM_MasterConfigTypeDef sMasterConfig;
  TIM_OC_InitTypeDef sConfigOC;

  htim2.Instance = TIM2;
 8001592:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
  htim2.Init.Prescaler = 0;
  htim2.Init.CounterMode = TIM_COUNTERMODE_CENTERALIGNED2;
 8001596:	2240      	movs	r2, #64	; 0x40
  htim2.Init.Period = 703;
 8001598:	f240 23bf 	movw	r3, #703	; 0x2bf
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
 800159c:	4620      	mov	r0, r4
  TIM_ClockConfigTypeDef sClockSourceConfig;
  TIM_MasterConfigTypeDef sMasterConfig;
  TIM_OC_InitTypeDef sConfigOC;

  htim2.Instance = TIM2;
  htim2.Init.Prescaler = 0;
 800159e:	6065      	str	r5, [r4, #4]
  htim2.Init.CounterMode = TIM_COUNTERMODE_CENTERALIGNED2;
  htim2.Init.Period = 703;
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 80015a0:	6125      	str	r5, [r4, #16]
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 80015a2:	61a5      	str	r5, [r4, #24]

  TIM_ClockConfigTypeDef sClockSourceConfig;
  TIM_MasterConfigTypeDef sMasterConfig;
  TIM_OC_InitTypeDef sConfigOC;

  htim2.Instance = TIM2;
 80015a4:	6021      	str	r1, [r4, #0]
  htim2.Init.Prescaler = 0;
  htim2.Init.CounterMode = TIM_COUNTERMODE_CENTERALIGNED2;
 80015a6:	60a2      	str	r2, [r4, #8]
  htim2.Init.Period = 703;
 80015a8:	60e3      	str	r3, [r4, #12]
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
 80015aa:	f7ff fe59 	bl	8001260 <HAL_TIM_Base_Init>
 80015ae:	b100      	cbz	r0, 80015b2 <main+0x76>
 80015b0:	e7fe      	b.n	80015b0 <main+0x74>
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 80015b2:	a910      	add	r1, sp, #64	; 0x40
 80015b4:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80015b8:	f841 3d2c 	str.w	r3, [r1, #-44]!
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
 80015bc:	4620      	mov	r0, r4
 80015be:	f7ff fd33 	bl	8001028 <HAL_TIM_ConfigClockSource>
 80015c2:	b100      	cbz	r0, 80015c6 <main+0x8a>
 80015c4:	e7fe      	b.n	80015c4 <main+0x88>
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  if (HAL_TIM_PWM_Init(&htim2) != HAL_OK)
 80015c6:	4620      	mov	r0, r4
 80015c8:	f7ff fe66 	bl	8001298 <HAL_TIM_PWM_Init>
 80015cc:	4603      	mov	r3, r0
 80015ce:	b100      	cbz	r0, 80015d2 <main+0x96>
 80015d0:	e7fe      	b.n	80015d0 <main+0x94>
    _Error_Handler(__FILE__, __LINE__);
  }

  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 80015d2:	a902      	add	r1, sp, #8
 80015d4:	4620      	mov	r0, r4
  if (HAL_TIM_PWM_Init(&htim2) != HAL_OK)
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 80015d6:	9302      	str	r3, [sp, #8]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 80015d8:	9304      	str	r3, [sp, #16]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 80015da:	f7ff ff47 	bl	800146c <HAL_TIMEx_MasterConfigSynchronization>
 80015de:	4603      	mov	r3, r0
 80015e0:	b100      	cbz	r0, 80015e4 <main+0xa8>
 80015e2:	e7fe      	b.n	80015e2 <main+0xa6>
  }

  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_ENABLE;
 80015e4:	2504      	movs	r5, #4
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 80015e6:	2660      	movs	r6, #96	; 0x60
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_ENABLE;
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 80015e8:	462a      	mov	r2, r5
 80015ea:	a909      	add	r1, sp, #36	; 0x24
 80015ec:	4620      	mov	r0, r4
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
 80015ee:	930a      	str	r3, [sp, #40]	; 0x28
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 80015f0:	930b      	str	r3, [sp, #44]	; 0x2c
  sConfigOC.OCFastMode = TIM_OCFAST_ENABLE;
 80015f2:	950d      	str	r5, [sp, #52]	; 0x34
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 80015f4:	9609      	str	r6, [sp, #36]	; 0x24
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_ENABLE;
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 80015f6:	f7ff fea5 	bl	8001344 <HAL_TIM_PWM_ConfigChannel>
 80015fa:	b100      	cbz	r0, 80015fe <main+0xc2>
 80015fc:	e7fe      	b.n	80015fc <main+0xc0>
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
 80015fe:	2208      	movs	r2, #8
 8001600:	a909      	add	r1, sp, #36	; 0x24
 8001602:	4620      	mov	r0, r4
 8001604:	f7ff fe9e 	bl	8001344 <HAL_TIM_PWM_ConfigChannel>
 8001608:	b100      	cbz	r0, 800160c <main+0xd0>
 800160a:	e7fe      	b.n	800160a <main+0xce>
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
 800160c:	a909      	add	r1, sp, #36	; 0x24
 800160e:	220c      	movs	r2, #12
 8001610:	4620      	mov	r0, r4
 8001612:	f7ff fe97 	bl	8001344 <HAL_TIM_PWM_ConfigChannel>
 8001616:	4680      	mov	r8, r0
 8001618:	b100      	cbz	r0, 800161c <main+0xe0>
 800161a:	e7fe      	b.n	800161a <main+0xde>
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  HAL_TIM_MspPostInit(&htim2);
 800161c:	4620      	mov	r0, r4
 800161e:	f000 f8b1 	bl	8001784 <HAL_TIM_MspPostInit>

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_TIM2_Init();
  /* USER CODE BEGIN 2 */
  HAL_TIM_Base_Start(&htim2);
 8001622:	4620      	mov	r0, r4
 8001624:	f7ff fcc6 	bl	8000fb4 <HAL_TIM_Base_Start>
  HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_4);
 8001628:	210c      	movs	r1, #12
 800162a:	4620      	mov	r0, r4
 800162c:	f7ff fcd4 	bl	8000fd8 <HAL_TIM_PWM_Start>
  HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_2);
 8001630:	4629      	mov	r1, r5
 8001632:	4620      	mov	r0, r4
 8001634:	f7ff fcd0 	bl	8000fd8 <HAL_TIM_PWM_Start>
  HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_3);
 8001638:	2108      	movs	r1, #8
 800163a:	4620      	mov	r0, r4
 800163c:	f7ff fccc 	bl	8000fd8 <HAL_TIM_PWM_Start>
 8001640:	4e20      	ldr	r6, [pc, #128]	; (80016c4 <main+0x188>)

  /* USER CODE BEGIN 3 */

	  for (int j = 0;j<=10000;j++){}

	  htim2.Instance->CCR4 = PWMdata2[s]/37;
 8001642:	6827      	ldr	r7, [r4, #0]
 8001644:	4d20      	ldr	r5, [pc, #128]	; (80016c8 <main+0x18c>)
  HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_3);
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  int i = 0;
 8001646:	4642      	mov	r2, r8
  int v = 84;
  int s = 168;
 8001648:	20a8      	movs	r0, #168	; 0xa8
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  int i = 0;
  int v = 84;
 800164a:	2154      	movs	r1, #84	; 0x54
  HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_3);
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  int i = 0;
 800164c:	f242 7311 	movw	r3, #10001	; 0x2711
  {
  /* USER CODE END WHILE */

  /* USER CODE BEGIN 3 */

	  for (int j = 0;j<=10000;j++){}
 8001650:	3b01      	subs	r3, #1
 8001652:	d1fd      	bne.n	8001650 <main+0x114>

	  htim2.Instance->CCR4 = PWMdata2[s]/37;
 8001654:	f836 e010 	ldrh.w	lr, [r6, r0, lsl #1]
	  htim2.Instance->CCR2 = PWMdata2[v]/37;
	  htim2.Instance->CCR3 = PWMdata2[i]/37;
 8001658:	f836 c012 	ldrh.w	ip, [r6, r2, lsl #1]
  /* USER CODE BEGIN 3 */

	  for (int j = 0;j<=10000;j++){}

	  htim2.Instance->CCR4 = PWMdata2[s]/37;
	  htim2.Instance->CCR2 = PWMdata2[v]/37;
 800165c:	f836 8011 	ldrh.w	r8, [r6, r1, lsl #1]

  /* USER CODE BEGIN 3 */

	  for (int j = 0;j<=10000;j++){}

	  htim2.Instance->CCR4 = PWMdata2[s]/37;
 8001660:	fba5 430e 	umull	r4, r3, r5, lr
 8001664:	ebc3 0e0e 	rsb	lr, r3, lr
	  htim2.Instance->CCR3 = PWMdata2[i]/37;

	  //__HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_4, PWMdata[s]);
	  //__HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_2, PWMdata[v]);
	  //__HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_3, PWMdata[i]);
	  i ++;
 8001668:	3201      	adds	r2, #1
  /* USER CODE BEGIN 3 */

	  for (int j = 0;j<=10000;j++){}

	  htim2.Instance->CCR4 = PWMdata2[s]/37;
	  htim2.Instance->CCR2 = PWMdata2[v]/37;
 800166a:	fba5 9408 	umull	r9, r4, r5, r8

  /* USER CODE BEGIN 3 */

	  for (int j = 0;j<=10000;j++){}

	  htim2.Instance->CCR4 = PWMdata2[s]/37;
 800166e:	eb03 0e5e 	add.w	lr, r3, lr, lsr #1
	  htim2.Instance->CCR2 = PWMdata2[v]/37;
	  htim2.Instance->CCR3 = PWMdata2[i]/37;
 8001672:	fba5 930c 	umull	r9, r3, r5, ip
	  //__HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_3, PWMdata[i]);
	  i ++;
	  v ++;
	  s ++;
	  if (i == 251){
		  i = 0;
 8001676:	2afb      	cmp	r2, #251	; 0xfb

	  //__HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_4, PWMdata[s]);
	  //__HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_2, PWMdata[v]);
	  //__HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_3, PWMdata[i]);
	  i ++;
	  v ++;
 8001678:	f101 0101 	add.w	r1, r1, #1
  /* USER CODE BEGIN 3 */

	  for (int j = 0;j<=10000;j++){}

	  htim2.Instance->CCR4 = PWMdata2[s]/37;
	  htim2.Instance->CCR2 = PWMdata2[v]/37;
 800167c:	ebc4 0808 	rsb	r8, r4, r8
	  htim2.Instance->CCR3 = PWMdata2[i]/37;
 8001680:	ebc3 0c0c 	rsb	ip, r3, ip
	  //__HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_4, PWMdata[s]);
	  //__HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_2, PWMdata[v]);
	  //__HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_3, PWMdata[i]);
	  i ++;
	  v ++;
	  s ++;
 8001684:	f100 0001 	add.w	r0, r0, #1
	  if (i == 251){
		  i = 0;
 8001688:	bf08      	it	eq
 800168a:	2200      	moveq	r2, #0
  /* USER CODE BEGIN 3 */

	  for (int j = 0;j<=10000;j++){}

	  htim2.Instance->CCR4 = PWMdata2[s]/37;
	  htim2.Instance->CCR2 = PWMdata2[v]/37;
 800168c:	eb04 0458 	add.w	r4, r4, r8, lsr #1
	  s ++;
	  if (i == 251){
		  i = 0;
	  }
	  if (v == 251){
		  v = 0;
 8001690:	29fb      	cmp	r1, #251	; 0xfb

	  for (int j = 0;j<=10000;j++){}

	  htim2.Instance->CCR4 = PWMdata2[s]/37;
	  htim2.Instance->CCR2 = PWMdata2[v]/37;
	  htim2.Instance->CCR3 = PWMdata2[i]/37;
 8001692:	eb03 035c 	add.w	r3, r3, ip, lsr #1

  /* USER CODE BEGIN 3 */

	  for (int j = 0;j<=10000;j++){}

	  htim2.Instance->CCR4 = PWMdata2[s]/37;
 8001696:	f3ce 1e4f 	ubfx	lr, lr, #5, #16
	  s ++;
	  if (i == 251){
		  i = 0;
	  }
	  if (v == 251){
		  v = 0;
 800169a:	bf08      	it	eq
 800169c:	2100      	moveq	r1, #0
  /* USER CODE BEGIN 3 */

	  for (int j = 0;j<=10000;j++){}

	  htim2.Instance->CCR4 = PWMdata2[s]/37;
	  htim2.Instance->CCR2 = PWMdata2[v]/37;
 800169e:	f3c4 144f 	ubfx	r4, r4, #5, #16
	  }
	  if (v == 251){
		  v = 0;
	  }
	  if (s == 251){
		  s = 0;
 80016a2:	28fb      	cmp	r0, #251	; 0xfb

	  for (int j = 0;j<=10000;j++){}

	  htim2.Instance->CCR4 = PWMdata2[s]/37;
	  htim2.Instance->CCR2 = PWMdata2[v]/37;
	  htim2.Instance->CCR3 = PWMdata2[i]/37;
 80016a4:	f3c3 134f 	ubfx	r3, r3, #5, #16

  /* USER CODE BEGIN 3 */

	  for (int j = 0;j<=10000;j++){}

	  htim2.Instance->CCR4 = PWMdata2[s]/37;
 80016a8:	f8c7 e040 	str.w	lr, [r7, #64]	; 0x40
	  }
	  if (v == 251){
		  v = 0;
	  }
	  if (s == 251){
		  s = 0;
 80016ac:	bf08      	it	eq
 80016ae:	2000      	moveq	r0, #0
  /* USER CODE BEGIN 3 */

	  for (int j = 0;j<=10000;j++){}

	  htim2.Instance->CCR4 = PWMdata2[s]/37;
	  htim2.Instance->CCR2 = PWMdata2[v]/37;
 80016b0:	63bc      	str	r4, [r7, #56]	; 0x38
	  htim2.Instance->CCR3 = PWMdata2[i]/37;
 80016b2:	63fb      	str	r3, [r7, #60]	; 0x3c
 80016b4:	e7ca      	b.n	800164c <main+0x110>
 80016b6:	bf00      	nop
 80016b8:	40021000 	.word	0x40021000
 80016bc:	20000024 	.word	0x20000024
 80016c0:	48000400 	.word	0x48000400
 80016c4:	080018e0 	.word	0x080018e0
 80016c8:	bacf914d 	.word	0xbacf914d

080016cc <HAL_MspInit>:
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80016cc:	4b22      	ldr	r3, [pc, #136]	; (8001758 <HAL_MspInit+0x8c>)
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 80016ce:	b500      	push	{lr}
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80016d0:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 80016d2:	f042 0201 	orr.w	r2, r2, #1
 80016d6:	661a      	str	r2, [r3, #96]	; 0x60
 80016d8:	6e1a      	ldr	r2, [r3, #96]	; 0x60
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 80016da:	b083      	sub	sp, #12
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80016dc:	f002 0201 	and.w	r2, r2, #1
 80016e0:	9200      	str	r2, [sp, #0]
 80016e2:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 80016e4:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80016e6:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80016ea:	659a      	str	r2, [r3, #88]	; 0x58
 80016ec:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80016ee:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80016f2:	9301      	str	r3, [sp, #4]

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80016f4:	2003      	movs	r0, #3
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
  __HAL_RCC_PWR_CLK_ENABLE();
 80016f6:	9b01      	ldr	r3, [sp, #4]

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80016f8:	f7fe fd98 	bl	800022c <HAL_NVIC_SetPriorityGrouping>

  /* System interrupt init*/
  /* MemoryManagement_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);
 80016fc:	2200      	movs	r2, #0
 80016fe:	4611      	mov	r1, r2
 8001700:	f06f 000b 	mvn.w	r0, #11
 8001704:	f7fe fda4 	bl	8000250 <HAL_NVIC_SetPriority>
  /* BusFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);
 8001708:	2200      	movs	r2, #0
 800170a:	4611      	mov	r1, r2
 800170c:	f06f 000a 	mvn.w	r0, #10
 8001710:	f7fe fd9e 	bl	8000250 <HAL_NVIC_SetPriority>
  /* UsageFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);
 8001714:	2200      	movs	r2, #0
 8001716:	4611      	mov	r1, r2
 8001718:	f06f 0009 	mvn.w	r0, #9
 800171c:	f7fe fd98 	bl	8000250 <HAL_NVIC_SetPriority>
  /* SVCall_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SVCall_IRQn, 0, 0);
 8001720:	2200      	movs	r2, #0
 8001722:	4611      	mov	r1, r2
 8001724:	f06f 0004 	mvn.w	r0, #4
 8001728:	f7fe fd92 	bl	8000250 <HAL_NVIC_SetPriority>
  /* DebugMonitor_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);
 800172c:	2200      	movs	r2, #0
 800172e:	4611      	mov	r1, r2
 8001730:	f06f 0003 	mvn.w	r0, #3
 8001734:	f7fe fd8c 	bl	8000250 <HAL_NVIC_SetPriority>
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0);
 8001738:	2200      	movs	r2, #0
 800173a:	4611      	mov	r1, r2
 800173c:	f06f 0001 	mvn.w	r0, #1
 8001740:	f7fe fd86 	bl	8000250 <HAL_NVIC_SetPriority>
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 8001744:	2200      	movs	r2, #0
 8001746:	4611      	mov	r1, r2
 8001748:	f04f 30ff 	mov.w	r0, #4294967295
 800174c:	f7fe fd80 	bl	8000250 <HAL_NVIC_SetPriority>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8001750:	b003      	add	sp, #12
 8001752:	f85d fb04 	ldr.w	pc, [sp], #4
 8001756:	bf00      	nop
 8001758:	40021000 	.word	0x40021000

0800175c <HAL_TIM_Base_MspInit>:

void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)
{

  if(htim_base->Instance==TIM2)
 800175c:	6803      	ldr	r3, [r0, #0]
 800175e:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8001762:	d000      	beq.n	8001766 <HAL_TIM_Base_MspInit+0xa>
  /* USER CODE BEGIN TIM2_MspInit 1 */

  /* USER CODE END TIM2_MspInit 1 */
  }

}
 8001764:	4770      	bx	lr
  {
  /* USER CODE BEGIN TIM2_MspInit 0 */

  /* USER CODE END TIM2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM2_CLK_ENABLE();
 8001766:	f503 3304 	add.w	r3, r3, #135168	; 0x21000

  /* USER CODE END MspInit 1 */
}

void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)
{
 800176a:	b082      	sub	sp, #8
  {
  /* USER CODE BEGIN TIM2_MspInit 0 */

  /* USER CODE END TIM2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM2_CLK_ENABLE();
 800176c:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800176e:	f042 0201 	orr.w	r2, r2, #1
 8001772:	659a      	str	r2, [r3, #88]	; 0x58
 8001774:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8001776:	f003 0301 	and.w	r3, r3, #1
 800177a:	9301      	str	r3, [sp, #4]
 800177c:	9b01      	ldr	r3, [sp, #4]
  /* USER CODE BEGIN TIM2_MspInit 1 */

  /* USER CODE END TIM2_MspInit 1 */
  }

}
 800177e:	b002      	add	sp, #8
 8001780:	4770      	bx	lr
 8001782:	bf00      	nop

08001784 <HAL_TIM_MspPostInit>:

void HAL_TIM_MspPostInit(TIM_HandleTypeDef* htim)
{

  GPIO_InitTypeDef GPIO_InitStruct;
  if(htim->Instance==TIM2)
 8001784:	6803      	ldr	r3, [r0, #0]
 8001786:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800178a:	d000      	beq.n	800178e <HAL_TIM_MspPostInit+0xa>
 800178c:	4770      	bx	lr
  }

}

void HAL_TIM_MspPostInit(TIM_HandleTypeDef* htim)
{
 800178e:	b530      	push	{r4, r5, lr}
 8001790:	b087      	sub	sp, #28
    PA2     ------> TIM2_CH3
    PA3     ------> TIM2_CH4 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001792:	2300      	movs	r3, #0
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 8001794:	2201      	movs	r2, #1
    /**TIM2 GPIO Configuration    
    PA1     ------> TIM2_CH2
    PA2     ------> TIM2_CH3
    PA3     ------> TIM2_CH4 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3;
 8001796:	250e      	movs	r5, #14
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001798:	2402      	movs	r4, #2
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800179a:	a901      	add	r1, sp, #4
 800179c:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    /**TIM2 GPIO Configuration    
    PA1     ------> TIM2_CH2
    PA2     ------> TIM2_CH3
    PA3     ------> TIM2_CH4 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3;
 80017a0:	9501      	str	r5, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80017a2:	9402      	str	r4, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80017a4:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80017a6:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 80017a8:	9205      	str	r2, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80017aa:	f7fe fdb5 	bl	8000318 <HAL_GPIO_Init>
  /* USER CODE BEGIN TIM2_MspPostInit 1 */

  /* USER CODE END TIM2_MspPostInit 1 */
  }

}
 80017ae:	b007      	add	sp, #28
 80017b0:	bd30      	pop	{r4, r5, pc}
 80017b2:	bf00      	nop

080017b4 <NMI_Handler>:
 80017b4:	4770      	bx	lr
 80017b6:	bf00      	nop

080017b8 <HardFault_Handler>:

/**
* @brief This function handles Hard fault interrupt.
*/
void HardFault_Handler(void)
{
 80017b8:	e7fe      	b.n	80017b8 <HardFault_Handler>
 80017ba:	bf00      	nop

080017bc <MemManage_Handler>:

/**
* @brief This function handles Memory management fault.
*/
void MemManage_Handler(void)
{
 80017bc:	e7fe      	b.n	80017bc <MemManage_Handler>
 80017be:	bf00      	nop

080017c0 <BusFault_Handler>:

/**
* @brief This function handles Prefetch fault, memory access fault.
*/
void BusFault_Handler(void)
{
 80017c0:	e7fe      	b.n	80017c0 <BusFault_Handler>
 80017c2:	bf00      	nop

080017c4 <UsageFault_Handler>:

/**
* @brief This function handles Undefined instruction or illegal state.
*/
void UsageFault_Handler(void)
{
 80017c4:	e7fe      	b.n	80017c4 <UsageFault_Handler>
 80017c6:	bf00      	nop

080017c8 <SVC_Handler>:
 80017c8:	4770      	bx	lr
 80017ca:	bf00      	nop

080017cc <DebugMon_Handler>:
 80017cc:	4770      	bx	lr
 80017ce:	bf00      	nop

080017d0 <PendSV_Handler>:

/**
* @brief This function handles Pendable request for system service.
*/
void PendSV_Handler(void)
{
 80017d0:	4770      	bx	lr
 80017d2:	bf00      	nop

080017d4 <SysTick_Handler>:

/**
* @brief This function handles System tick timer.
*/
void SysTick_Handler(void)
{
 80017d4:	b508      	push	{r3, lr}
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 80017d6:	f7fe fd1b 	bl	8000210 <HAL_IncTick>
  HAL_SYSTICK_IRQHandler();
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 80017da:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
  HAL_SYSTICK_IRQHandler();
 80017de:	f7fe bd97 	b.w	8000310 <HAL_SYSTICK_IRQHandler>
 80017e2:	bf00      	nop

080017e4 <SystemInit>:
  //  SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
  //#endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 80017e4:	4b0e      	ldr	r3, [pc, #56]	; (8001820 <SystemInit+0x3c>)

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 80017e6:	480f      	ldr	r0, [pc, #60]	; (8001824 <SystemInit+0x40>)
  //  SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
  //#endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 80017e8:	681a      	ldr	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000U;
 80017ea:	2100      	movs	r1, #0
  //  SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
  //#endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 80017ec:	f042 0201 	orr.w	r2, r2, #1
  * @param  None
  * @retval None
  */

void SystemInit(void)
{
 80017f0:	b410      	push	{r4}
  //  SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
  //#endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 80017f2:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000U;
 80017f4:	6099      	str	r1, [r3, #8]

  /* Reset HSEON, CSSON , HSION, and PLLON bits */
  RCC->CR &= 0xEAF6FFFFU;
 80017f6:	681a      	ldr	r2, [r3, #0]
 80017f8:	f022 52a8 	bic.w	r2, r2, #352321536	; 0x15000000
 80017fc:	f422 2210 	bic.w	r2, r2, #589824	; 0x90000

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00001000U;
 8001800:	f44f 5480 	mov.w	r4, #4096	; 0x1000

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000U;

  /* Reset HSEON, CSSON , HSION, and PLLON bits */
  RCC->CR &= 0xEAF6FFFFU;
 8001804:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00001000U;
 8001806:	60dc      	str	r4, [r3, #12]

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
 8001808:	681a      	ldr	r2, [r3, #0]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800180a:	f04f 6400 	mov.w	r4, #134217728	; 0x8000000

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00001000U;

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
 800180e:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8001812:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000U;
 8001814:	6199      	str	r1, [r3, #24]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8001816:	6084      	str	r4, [r0, #8]
#endif
}
 8001818:	f85d 4b04 	ldr.w	r4, [sp], #4
 800181c:	4770      	bx	lr
 800181e:	bf00      	nop
 8001820:	40021000 	.word	0x40021000
 8001824:	e000ed00 	.word	0xe000ed00

08001828 <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 8001828:	f8df d034 	ldr.w	sp, [pc, #52]	; 8001860 <LoopForever+0x2>

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 800182c:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 800182e:	e003      	b.n	8001838 <LoopCopyDataInit>

08001830 <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 8001830:	4b0c      	ldr	r3, [pc, #48]	; (8001864 <LoopForever+0x6>)
	ldr	r3, [r3, r1]
 8001832:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 8001834:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 8001836:	3104      	adds	r1, #4

08001838 <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
 8001838:	480b      	ldr	r0, [pc, #44]	; (8001868 <LoopForever+0xa>)
	ldr	r3, =_edata
 800183a:	4b0c      	ldr	r3, [pc, #48]	; (800186c <LoopForever+0xe>)
	adds	r2, r0, r1
 800183c:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 800183e:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 8001840:	d3f6      	bcc.n	8001830 <CopyDataInit>
	ldr	r2, =_sbss
 8001842:	4a0b      	ldr	r2, [pc, #44]	; (8001870 <LoopForever+0x12>)
	b	LoopFillZerobss
 8001844:	e002      	b.n	800184c <LoopFillZerobss>

08001846 <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 8001846:	2300      	movs	r3, #0
	str	r3, [r2], #4
 8001848:	f842 3b04 	str.w	r3, [r2], #4

0800184c <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 800184c:	4b09      	ldr	r3, [pc, #36]	; (8001874 <LoopForever+0x16>)
	cmp	r2, r3
 800184e:	429a      	cmp	r2, r3
	bcc	FillZerobss
 8001850:	d3f9      	bcc.n	8001846 <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 8001852:	f7ff ffc7 	bl	80017e4 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8001856:	f000 f811 	bl	800187c <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 800185a:	f7ff fe6f 	bl	800153c <main>

0800185e <LoopForever>:

LoopForever:
    b LoopForever
 800185e:	e7fe      	b.n	800185e <LoopForever>

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 8001860:	20010000 	.word	0x20010000
/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
  b	LoopCopyDataInit

CopyDataInit:
	ldr	r3, =_sidata
 8001864:	08001b28 	.word	0x08001b28
	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
	adds	r1, r1, #4

LoopCopyDataInit:
	ldr	r0, =_sdata
 8001868:	20000000 	.word	0x20000000
	ldr	r3, =_edata
 800186c:	20000004 	.word	0x20000004
	adds	r2, r0, r1
	cmp	r2, r3
	bcc	CopyDataInit
	ldr	r2, =_sbss
 8001870:	20000004 	.word	0x20000004
FillZerobss:
	movs	r3, #0
	str	r3, [r2], #4

LoopFillZerobss:
	ldr	r3, = _ebss
 8001874:	20000064 	.word	0x20000064

08001878 <ADC1_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 8001878:	e7fe      	b.n	8001878 <ADC1_IRQHandler>
	...

0800187c <__libc_init_array>:
 800187c:	b570      	push	{r4, r5, r6, lr}
 800187e:	4b0e      	ldr	r3, [pc, #56]	; (80018b8 <__libc_init_array+0x3c>)
 8001880:	4c0e      	ldr	r4, [pc, #56]	; (80018bc <__libc_init_array+0x40>)
 8001882:	1ae4      	subs	r4, r4, r3
 8001884:	10a4      	asrs	r4, r4, #2
 8001886:	2500      	movs	r5, #0
 8001888:	461e      	mov	r6, r3
 800188a:	42a5      	cmp	r5, r4
 800188c:	d004      	beq.n	8001898 <__libc_init_array+0x1c>
 800188e:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8001892:	4798      	blx	r3
 8001894:	3501      	adds	r5, #1
 8001896:	e7f8      	b.n	800188a <__libc_init_array+0xe>
 8001898:	f000 f816 	bl	80018c8 <_init>
 800189c:	4c08      	ldr	r4, [pc, #32]	; (80018c0 <__libc_init_array+0x44>)
 800189e:	4b09      	ldr	r3, [pc, #36]	; (80018c4 <__libc_init_array+0x48>)
 80018a0:	1ae4      	subs	r4, r4, r3
 80018a2:	10a4      	asrs	r4, r4, #2
 80018a4:	2500      	movs	r5, #0
 80018a6:	461e      	mov	r6, r3
 80018a8:	42a5      	cmp	r5, r4
 80018aa:	d004      	beq.n	80018b6 <__libc_init_array+0x3a>
 80018ac:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80018b0:	4798      	blx	r3
 80018b2:	3501      	adds	r5, #1
 80018b4:	e7f8      	b.n	80018a8 <__libc_init_array+0x2c>
 80018b6:	bd70      	pop	{r4, r5, r6, pc}
 80018b8:	08001b20 	.word	0x08001b20
 80018bc:	08001b20 	.word	0x08001b20
 80018c0:	08001b24 	.word	0x08001b24
 80018c4:	08001b20 	.word	0x08001b20

080018c8 <_init>:
 80018c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80018ca:	bf00      	nop
 80018cc:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80018ce:	bc08      	pop	{r3}
 80018d0:	469e      	mov	lr, r3
 80018d2:	4770      	bx	lr

080018d4 <_fini>:
 80018d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80018d6:	bf00      	nop
 80018d8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80018da:	bc08      	pop	{r3}
 80018dc:	469e      	mov	lr, r3
 80018de:	4770      	bx	lr
